/**
 * The MIT License (MIT)
 *
 * Copyright (c) 2018-2019 Erik Moqvist
 *
 * Permission is hereby granted, free of charge, to any person
 * obtaining a copy of this software and associated documentation
 * files (the "Software"), to deal in the Software without
 * restriction, including without limitation the rights to use, copy,
 * modify, merge, publish, distribute, sublicense, and/or sell copies
 * of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
 * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
 * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

/**
 * This file was generated by cantools version 35.3.0 Thu Dec 14 00:39:25 2023.
 */

#ifndef CAN1_H
#define CAN1_H

#ifdef __cplusplus
extern "C" {
#endif

#include <stdint.h>
#include <stdbool.h>
#include <stddef.h>

#ifndef EINVAL
#    define EINVAL 22
#endif

/* Frame ids. */
#define CAN1_AMS_STATUS_1_FRAME_ID (0x20u)
#define CAN1_AMS_STATE_FRAME_ID (0x1fu)
#define CAN1_AMS_ERROR_FRAME_ID (0x1eu)
#define CAN1_DV_DRIVING_DYNAMICS_1_FRAME_ID (0x500u)
#define CAN1_DV_DRIVING_DYNAMICS_2_FRAME_ID (0x501u)
#define CAN1_DV_SYSTEM_STATUS_FRAME_ID (0x502u)
#define CAN1_MCU_SET_ECU_INDICATOR_POINTS_FRAME_ID (0x50cu)
#define CAN1_MCU_SET_DBU_INDICATOR_POINTS_FRAME_ID (0x50du)
#define CAN1_RES_STATUS_FRAME_ID (0x191u)
#define CAN1_RES_INITIALIZATION_FRAME_ID (0x711u)
#define CAN1_RES_NMT_NODE_CONTROL_FRAME_ID (0x00u)
#define CAN1_SWU_STATUS_FRAME_ID (0x38u)
#define CAN1_DBU_STATUS_1_FRAME_ID (0x40u)
#define CAN1_LV_POWER_SIGNAL_FRAME_ID (0x63u)
#define CAN1_LV_BMS_DATA_A_FRAME_ID (0x64u)
#define CAN1_LV_BMS_STATUS_A_FRAME_ID (0x65u)
#define CAN1_AMS_TEMPERATURES_FRAME_ID (0x24u)
#define CAN1_AMS_CELL_VOLTAGES_FRAME_ID (0x21u)
#define CAN1_AMS_CELL_TEMPERATURES_FRAME_ID (0x22u)
#define CAN1_ECU_STATUS_FRAME_ID (0x48u)
#define CAN1_EBS_STATUS_FRAME_ID (0x50u)
#define CAN1_DCU_PPS_FRAME_ID (0x10u)
#define CAN1_DCU_STATUS_FRAME_ID (0x12u)
#define CAN1_MCU_SET_CCU_COOLING_POINTS_FRAME_ID (0x5au)
#define CAN1_CCU_STATUS_1_FRAME_ID (0x59u)
#define CAN1_CCU_STATUS_2_FRAME_ID (0x58u)
#define CAN1_VEHICLE_STATUS_FRAME_ID (0x28u)
#define CAN1_FAULT_FRAME_ID (0xffu)
#define CAN1_DCU_STATUS_STEERING_BRAKE_FRAME_ID (0x11u)
#define CAN1_DBU_STATUS_2_FRAME_ID (0x41u)
#define CAN1_DV_CONTROL_TARGET_FRAME_ID (0x18u)
#define CAN1_VEHICLE_STATUS_WHEEL_SPEED_FRAME_ID (0x29u)
#define CAN1_SBG_ECAN_MSG_GPS2_HDT_FRAME_ID (0x189u)
#define CAN1_SBG_ECAN_MSG_GPS2_HDT_INFO_FRAME_ID (0x188u)
#define CAN1_SBG_ECAN_MSG_GPS2_POS_ACC_FRAME_ID (0x187u)
#define CAN1_SBG_ECAN_MSG_GPS2_POS_ALT_FRAME_ID (0x186u)
#define CAN1_SBG_ECAN_MSG_GPS2_POS_FRAME_ID (0x185u)
#define CAN1_SBG_ECAN_MSG_GPS2_POS_INFO_FRAME_ID (0x184u)
#define CAN1_SBG_ECAN_MSG_GPS2_VEL_COURSE_FRAME_ID (0x183u)
#define CAN1_SBG_ECAN_MSG_GPS2_VEL_ACC_FRAME_ID (0x182u)
#define CAN1_SBG_ECAN_MSG_GPS2_VEL_FRAME_ID (0x181u)
#define CAN1_SBG_ECAN_MSG_GPS2_VEL_INFO_FRAME_ID (0x180u)
#define CAN1_SBG_ECAN_MSG_GPS1_HDT_FRAME_ID (0x179u)
#define CAN1_SBG_ECAN_MSG_GPS1_HDT_INFO_FRAME_ID (0x178u)
#define CAN1_SBG_ECAN_MSG_GPS1_POS_ACC_FRAME_ID (0x177u)
#define CAN1_SBG_ECAN_MSG_GPS1_POS_ALT_FRAME_ID (0x176u)
#define CAN1_SBG_ECAN_MSG_GPS1_POS_FRAME_ID (0x175u)
#define CAN1_SBG_ECAN_MSG_GPS1_POS_INFO_FRAME_ID (0x174u)
#define CAN1_SBG_ECAN_MSG_GPS1_VEL_COURSE_FRAME_ID (0x173u)
#define CAN1_SBG_ECAN_MSG_GPS1_VEL_ACC_FRAME_ID (0x172u)
#define CAN1_SBG_ECAN_MSG_GPS1_VEL_FRAME_ID (0x171u)
#define CAN1_SBG_ECAN_MSG_GPS1_VEL_INFO_FRAME_ID (0x170u)
#define CAN1_SBG_ECAN_MSG_ODO_VEL_FRAME_ID (0x161u)
#define CAN1_SBG_ECAN_MSG_ODO_INFO_FRAME_ID (0x160u)
#define CAN1_SBG_ECAN_MSG_EKF_VEL_BODY_FRAME_ID (0x139u)
#define CAN1_SBG_ECAN_MSG_EKF_VEL_NED_ACC_FRAME_ID (0x138u)
#define CAN1_SBG_ECAN_MSG_EKF_VEL_NED_FRAME_ID (0x137u)
#define CAN1_SBG_ECAN_MSG_EKF_POS_ACC_FRAME_ID (0x136u)
#define CAN1_SBG_ECAN_MSG_EKF_POS_FRAME_ID (0x134u)
#define CAN1_SBG_ECAN_MSG_EKF_ORIENTATION_ACC_FRAME_ID (0x133u)
#define CAN1_SBG_ECAN_MSG_EKF_EULER_FRAME_ID (0x132u)
#define CAN1_SBG_ECAN_MSG_EKF_QUAT_FRAME_ID (0x131u)
#define CAN1_SBG_ECAN_MSG_EKF_INFO_FRAME_ID (0x130u)
#define CAN1_SBG_ECAN_MSG_IMU_DELTA_ANGLE_FRAME_ID (0x124u)
#define CAN1_SBG_ECAN_MSG_IMU_DELTA_VEL_FRAME_ID (0x123u)
#define CAN1_SBG_ECAN_MSG_IMU_GYRO_FRAME_ID (0x122u)
#define CAN1_SBG_ECAN_MSG_IMU_ACCEL_FRAME_ID (0x121u)
#define CAN1_SBG_ECAN_MSG_IMU_INFO_FRAME_ID (0x120u)
#define CAN1_SBG_ECAN_MSG_UTC_1_FRAME_ID (0x111u)
#define CAN1_SBG_ECAN_MSG_UTC_0_FRAME_ID (0x110u)
#define CAN1_FS_DATALOGGER_RESERVED_6_FRAME_ID (0x755u)
#define CAN1_FS_DATALOGGER_RESERVED_5_FRAME_ID (0x754u)
#define CAN1_FS_DATALOGGER_RESERVED_4_FRAME_ID (0x753u)
#define CAN1_FS_DATALOGGER_RESERVED_3_FRAME_ID (0x752u)
#define CAN1_FS_DATALOGGER_RESERVED_2_FRAME_ID (0x751u)
#define CAN1_FS_DATALOGGER_RESERVED_1_FRAME_ID (0x750u)
#define CAN1_FS_DATALOGGER_STATUS_FRAME_ID (0x430u)
#define CAN1_VESC_STATUS_2_FRAME_ID (0xe19u)
#define CAN1_VESC_STATUS_4_FRAME_ID (0x1019u)
#define CAN1_VESC_STATUS_5_FRAME_ID (0x1b19u)
#define CAN1_VESC_STATUS_6_FRAME_ID (0x3a19u)
#define CAN1_VESC_SET_DUTY_FRAME_ID (0x19u)
#define CAN1_VESC_STATUS_FRAME_ID (0x919u)
#define CAN1_AMS_S1_VOLTAGES_1_FRAME_ID (0x200u)
#define CAN1_AMS_S1_VOLTAGES_2_FRAME_ID (0x201u)
#define CAN1_AMS_S2_VOLTAGES_1_FRAME_ID (0x202u)
#define CAN1_AMS_S2_VOLTAGES_2_FRAME_ID (0x203u)
#define CAN1_AMS_S3_VOLTAGES_1_FRAME_ID (0x204u)
#define CAN1_AMS_S3_VOLTAGES_2_FRAME_ID (0x205u)
#define CAN1_AMS_S4_VOLTAGES_1_FRAME_ID (0x206u)
#define CAN1_AMS_S4_VOLTAGES_2_FRAME_ID (0x207u)
#define CAN1_AMS_S5_VOLTAGES_1_FRAME_ID (0x208u)
#define CAN1_AMS_S5_VOLTAGES_2_FRAME_ID (0x209u)
#define CAN1_AMS_S6_VOLTAGES_1_FRAME_ID (0x20au)
#define CAN1_AMS_S6_VOLTAGES_2_FRAME_ID (0x20bu)
#define CAN1_AMS_S7_VOLTAGES_1_FRAME_ID (0x20cu)
#define CAN1_AMS_S7_VOLTAGES_2_FRAME_ID (0x20du)
#define CAN1_AMS_S8_VOLTAGES_1_FRAME_ID (0x20eu)
#define CAN1_AMS_S8_VOLTAGES_2_FRAME_ID (0x20fu)
#define CAN1_AMS_S9_VOLTAGES_1_FRAME_ID (0x210u)
#define CAN1_AMS_S9_VOLTAGES_2_FRAME_ID (0x211u)
#define CAN1_AMS_S10_VOLTAGES_1_FRAME_ID (0x212u)
#define CAN1_AMS_S10_VOLTAGES_2_FRAME_ID (0x213u)
#define CAN1_AMS_S11_VOLTAGES_1_FRAME_ID (0x214u)
#define CAN1_AMS_S11_VOLTAGES_2_FRAME_ID (0x215u)
#define CAN1_AMS_S12_VOLTAGES_1_FRAME_ID (0x216u)
#define CAN1_AMS_S12_VOLTAGES_2_FRAME_ID (0x217u)
#define CAN1_IVT_IMPROVED_STATUS_FRAME_ID (0x1du)
#define CAN1_RES_RECIEVE_PDO_FRAME_ID (0x211u)
#define CAN1_RES_TRANSMIT_SDO_FRAME_ID (0x591u)
#define CAN1_RES_RECIEVE_SDO_FRAME_ID (0x611u)
#define CAN1_RES_TRANSMIT_LSS_FRAME_ID (0x7e4u)
#define CAN1_RES_RECIEVE_LSS_FRAME_ID (0x7e5u)

/* Frame lengths in bytes. */
#define CAN1_AMS_STATUS_1_LENGTH (8u)
#define CAN1_AMS_STATE_LENGTH (8u)
#define CAN1_AMS_ERROR_LENGTH (8u)
#define CAN1_DV_DRIVING_DYNAMICS_1_LENGTH (8u)
#define CAN1_DV_DRIVING_DYNAMICS_2_LENGTH (6u)
#define CAN1_DV_SYSTEM_STATUS_LENGTH (5u)
#define CAN1_MCU_SET_ECU_INDICATOR_POINTS_LENGTH (8u)
#define CAN1_MCU_SET_DBU_INDICATOR_POINTS_LENGTH (1u)
#define CAN1_RES_STATUS_LENGTH (8u)
#define CAN1_RES_INITIALIZATION_LENGTH (8u)
#define CAN1_RES_NMT_NODE_CONTROL_LENGTH (8u)
#define CAN1_SWU_STATUS_LENGTH (8u)
#define CAN1_DBU_STATUS_1_LENGTH (8u)
#define CAN1_LV_POWER_SIGNAL_LENGTH (8u)
#define CAN1_LV_BMS_DATA_A_LENGTH (8u)
#define CAN1_LV_BMS_STATUS_A_LENGTH (8u)
#define CAN1_AMS_TEMPERATURES_LENGTH (6u)
#define CAN1_AMS_CELL_VOLTAGES_LENGTH (7u)
#define CAN1_AMS_CELL_TEMPERATURES_LENGTH (8u)
#define CAN1_ECU_STATUS_LENGTH (1u)
#define CAN1_EBS_STATUS_LENGTH (5u)
#define CAN1_DCU_PPS_LENGTH (8u)
#define CAN1_DCU_STATUS_LENGTH (6u)
#define CAN1_MCU_SET_CCU_COOLING_POINTS_LENGTH (8u)
#define CAN1_CCU_STATUS_1_LENGTH (8u)
#define CAN1_CCU_STATUS_2_LENGTH (8u)
#define CAN1_VEHICLE_STATUS_LENGTH (8u)
#define CAN1_FAULT_LENGTH (8u)
#define CAN1_DCU_STATUS_STEERING_BRAKE_LENGTH (8u)
#define CAN1_DBU_STATUS_2_LENGTH (8u)
#define CAN1_DV_CONTROL_TARGET_LENGTH (8u)
#define CAN1_VEHICLE_STATUS_WHEEL_SPEED_LENGTH (8u)
#define CAN1_SBG_ECAN_MSG_GPS2_HDT_LENGTH (8u)
#define CAN1_SBG_ECAN_MSG_GPS2_HDT_INFO_LENGTH (6u)
#define CAN1_SBG_ECAN_MSG_GPS2_POS_ACC_LENGTH (8u)
#define CAN1_SBG_ECAN_MSG_GPS2_POS_ALT_LENGTH (8u)
#define CAN1_SBG_ECAN_MSG_GPS2_POS_LENGTH (8u)
#define CAN1_SBG_ECAN_MSG_GPS2_POS_INFO_LENGTH (8u)
#define CAN1_SBG_ECAN_MSG_GPS2_VEL_COURSE_LENGTH (4u)
#define CAN1_SBG_ECAN_MSG_GPS2_VEL_ACC_LENGTH (6u)
#define CAN1_SBG_ECAN_MSG_GPS2_VEL_LENGTH (6u)
#define CAN1_SBG_ECAN_MSG_GPS2_VEL_INFO_LENGTH (8u)
#define CAN1_SBG_ECAN_MSG_GPS1_HDT_LENGTH (8u)
#define CAN1_SBG_ECAN_MSG_GPS1_HDT_INFO_LENGTH (6u)
#define CAN1_SBG_ECAN_MSG_GPS1_POS_ACC_LENGTH (8u)
#define CAN1_SBG_ECAN_MSG_GPS1_POS_ALT_LENGTH (8u)
#define CAN1_SBG_ECAN_MSG_GPS1_POS_LENGTH (8u)
#define CAN1_SBG_ECAN_MSG_GPS1_POS_INFO_LENGTH (8u)
#define CAN1_SBG_ECAN_MSG_GPS1_VEL_COURSE_LENGTH (4u)
#define CAN1_SBG_ECAN_MSG_GPS1_VEL_ACC_LENGTH (6u)
#define CAN1_SBG_ECAN_MSG_GPS1_VEL_LENGTH (6u)
#define CAN1_SBG_ECAN_MSG_GPS1_VEL_INFO_LENGTH (8u)
#define CAN1_SBG_ECAN_MSG_ODO_VEL_LENGTH (2u)
#define CAN1_SBG_ECAN_MSG_ODO_INFO_LENGTH (6u)
#define CAN1_SBG_ECAN_MSG_EKF_VEL_BODY_LENGTH (6u)
#define CAN1_SBG_ECAN_MSG_EKF_VEL_NED_ACC_LENGTH (6u)
#define CAN1_SBG_ECAN_MSG_EKF_VEL_NED_LENGTH (6u)
#define CAN1_SBG_ECAN_MSG_EKF_POS_ACC_LENGTH (6u)
#define CAN1_SBG_ECAN_MSG_EKF_POS_LENGTH (8u)
#define CAN1_SBG_ECAN_MSG_EKF_ORIENTATION_ACC_LENGTH (6u)
#define CAN1_SBG_ECAN_MSG_EKF_EULER_LENGTH (6u)
#define CAN1_SBG_ECAN_MSG_EKF_QUAT_LENGTH (8u)
#define CAN1_SBG_ECAN_MSG_EKF_INFO_LENGTH (4u)
#define CAN1_SBG_ECAN_MSG_IMU_DELTA_ANGLE_LENGTH (6u)
#define CAN1_SBG_ECAN_MSG_IMU_DELTA_VEL_LENGTH (6u)
#define CAN1_SBG_ECAN_MSG_IMU_GYRO_LENGTH (6u)
#define CAN1_SBG_ECAN_MSG_IMU_ACCEL_LENGTH (6u)
#define CAN1_SBG_ECAN_MSG_IMU_INFO_LENGTH (8u)
#define CAN1_SBG_ECAN_MSG_UTC_1_LENGTH (8u)
#define CAN1_SBG_ECAN_MSG_UTC_0_LENGTH (8u)
#define CAN1_FS_DATALOGGER_RESERVED_6_LENGTH (8u)
#define CAN1_FS_DATALOGGER_RESERVED_5_LENGTH (8u)
#define CAN1_FS_DATALOGGER_RESERVED_4_LENGTH (8u)
#define CAN1_FS_DATALOGGER_RESERVED_3_LENGTH (8u)
#define CAN1_FS_DATALOGGER_RESERVED_2_LENGTH (8u)
#define CAN1_FS_DATALOGGER_RESERVED_1_LENGTH (8u)
#define CAN1_FS_DATALOGGER_STATUS_LENGTH (6u)
#define CAN1_VESC_STATUS_2_LENGTH (8u)
#define CAN1_VESC_STATUS_4_LENGTH (8u)
#define CAN1_VESC_STATUS_5_LENGTH (8u)
#define CAN1_VESC_STATUS_6_LENGTH (8u)
#define CAN1_VESC_SET_DUTY_LENGTH (8u)
#define CAN1_VESC_STATUS_LENGTH (8u)
#define CAN1_AMS_S1_VOLTAGES_1_LENGTH (6u)
#define CAN1_AMS_S1_VOLTAGES_2_LENGTH (5u)
#define CAN1_AMS_S2_VOLTAGES_1_LENGTH (6u)
#define CAN1_AMS_S2_VOLTAGES_2_LENGTH (5u)
#define CAN1_AMS_S3_VOLTAGES_1_LENGTH (6u)
#define CAN1_AMS_S3_VOLTAGES_2_LENGTH (5u)
#define CAN1_AMS_S4_VOLTAGES_1_LENGTH (6u)
#define CAN1_AMS_S4_VOLTAGES_2_LENGTH (5u)
#define CAN1_AMS_S5_VOLTAGES_1_LENGTH (6u)
#define CAN1_AMS_S5_VOLTAGES_2_LENGTH (5u)
#define CAN1_AMS_S6_VOLTAGES_1_LENGTH (6u)
#define CAN1_AMS_S6_VOLTAGES_2_LENGTH (5u)
#define CAN1_AMS_S7_VOLTAGES_1_LENGTH (6u)
#define CAN1_AMS_S7_VOLTAGES_2_LENGTH (5u)
#define CAN1_AMS_S8_VOLTAGES_1_LENGTH (6u)
#define CAN1_AMS_S8_VOLTAGES_2_LENGTH (5u)
#define CAN1_AMS_S9_VOLTAGES_1_LENGTH (6u)
#define CAN1_AMS_S9_VOLTAGES_2_LENGTH (5u)
#define CAN1_AMS_S10_VOLTAGES_1_LENGTH (6u)
#define CAN1_AMS_S10_VOLTAGES_2_LENGTH (5u)
#define CAN1_AMS_S11_VOLTAGES_1_LENGTH (6u)
#define CAN1_AMS_S11_VOLTAGES_2_LENGTH (5u)
#define CAN1_AMS_S12_VOLTAGES_1_LENGTH (6u)
#define CAN1_AMS_S12_VOLTAGES_2_LENGTH (5u)
#define CAN1_IVT_IMPROVED_STATUS_LENGTH (8u)
#define CAN1_RES_RECIEVE_PDO_LENGTH (8u)
#define CAN1_RES_TRANSMIT_SDO_LENGTH (8u)
#define CAN1_RES_RECIEVE_SDO_LENGTH (8u)
#define CAN1_RES_TRANSMIT_LSS_LENGTH (8u)
#define CAN1_RES_RECIEVE_LSS_LENGTH (8u)

/* Extended or standard frame types. */
#define CAN1_AMS_STATUS_1_IS_EXTENDED (0)
#define CAN1_AMS_STATE_IS_EXTENDED (0)
#define CAN1_AMS_ERROR_IS_EXTENDED (0)
#define CAN1_DV_DRIVING_DYNAMICS_1_IS_EXTENDED (0)
#define CAN1_DV_DRIVING_DYNAMICS_2_IS_EXTENDED (0)
#define CAN1_DV_SYSTEM_STATUS_IS_EXTENDED (0)
#define CAN1_MCU_SET_ECU_INDICATOR_POINTS_IS_EXTENDED (0)
#define CAN1_MCU_SET_DBU_INDICATOR_POINTS_IS_EXTENDED (0)
#define CAN1_RES_STATUS_IS_EXTENDED (0)
#define CAN1_RES_INITIALIZATION_IS_EXTENDED (0)
#define CAN1_RES_NMT_NODE_CONTROL_IS_EXTENDED (0)
#define CAN1_SWU_STATUS_IS_EXTENDED (0)
#define CAN1_DBU_STATUS_1_IS_EXTENDED (0)
#define CAN1_LV_POWER_SIGNAL_IS_EXTENDED (0)
#define CAN1_LV_BMS_DATA_A_IS_EXTENDED (0)
#define CAN1_LV_BMS_STATUS_A_IS_EXTENDED (0)
#define CAN1_AMS_TEMPERATURES_IS_EXTENDED (0)
#define CAN1_AMS_CELL_VOLTAGES_IS_EXTENDED (0)
#define CAN1_AMS_CELL_TEMPERATURES_IS_EXTENDED (0)
#define CAN1_ECU_STATUS_IS_EXTENDED (0)
#define CAN1_EBS_STATUS_IS_EXTENDED (0)
#define CAN1_DCU_PPS_IS_EXTENDED (0)
#define CAN1_DCU_STATUS_IS_EXTENDED (0)
#define CAN1_MCU_SET_CCU_COOLING_POINTS_IS_EXTENDED (0)
#define CAN1_CCU_STATUS_1_IS_EXTENDED (0)
#define CAN1_CCU_STATUS_2_IS_EXTENDED (0)
#define CAN1_VEHICLE_STATUS_IS_EXTENDED (0)
#define CAN1_FAULT_IS_EXTENDED (0)
#define CAN1_DCU_STATUS_STEERING_BRAKE_IS_EXTENDED (0)
#define CAN1_DBU_STATUS_2_IS_EXTENDED (0)
#define CAN1_DV_CONTROL_TARGET_IS_EXTENDED (0)
#define CAN1_VEHICLE_STATUS_WHEEL_SPEED_IS_EXTENDED (0)
#define CAN1_SBG_ECAN_MSG_GPS2_HDT_IS_EXTENDED (0)
#define CAN1_SBG_ECAN_MSG_GPS2_HDT_INFO_IS_EXTENDED (0)
#define CAN1_SBG_ECAN_MSG_GPS2_POS_ACC_IS_EXTENDED (0)
#define CAN1_SBG_ECAN_MSG_GPS2_POS_ALT_IS_EXTENDED (0)
#define CAN1_SBG_ECAN_MSG_GPS2_POS_IS_EXTENDED (0)
#define CAN1_SBG_ECAN_MSG_GPS2_POS_INFO_IS_EXTENDED (0)
#define CAN1_SBG_ECAN_MSG_GPS2_VEL_COURSE_IS_EXTENDED (0)
#define CAN1_SBG_ECAN_MSG_GPS2_VEL_ACC_IS_EXTENDED (0)
#define CAN1_SBG_ECAN_MSG_GPS2_VEL_IS_EXTENDED (0)
#define CAN1_SBG_ECAN_MSG_GPS2_VEL_INFO_IS_EXTENDED (0)
#define CAN1_SBG_ECAN_MSG_GPS1_HDT_IS_EXTENDED (0)
#define CAN1_SBG_ECAN_MSG_GPS1_HDT_INFO_IS_EXTENDED (0)
#define CAN1_SBG_ECAN_MSG_GPS1_POS_ACC_IS_EXTENDED (0)
#define CAN1_SBG_ECAN_MSG_GPS1_POS_ALT_IS_EXTENDED (0)
#define CAN1_SBG_ECAN_MSG_GPS1_POS_IS_EXTENDED (0)
#define CAN1_SBG_ECAN_MSG_GPS1_POS_INFO_IS_EXTENDED (0)
#define CAN1_SBG_ECAN_MSG_GPS1_VEL_COURSE_IS_EXTENDED (0)
#define CAN1_SBG_ECAN_MSG_GPS1_VEL_ACC_IS_EXTENDED (0)
#define CAN1_SBG_ECAN_MSG_GPS1_VEL_IS_EXTENDED (0)
#define CAN1_SBG_ECAN_MSG_GPS1_VEL_INFO_IS_EXTENDED (0)
#define CAN1_SBG_ECAN_MSG_ODO_VEL_IS_EXTENDED (0)
#define CAN1_SBG_ECAN_MSG_ODO_INFO_IS_EXTENDED (0)
#define CAN1_SBG_ECAN_MSG_EKF_VEL_BODY_IS_EXTENDED (0)
#define CAN1_SBG_ECAN_MSG_EKF_VEL_NED_ACC_IS_EXTENDED (0)
#define CAN1_SBG_ECAN_MSG_EKF_VEL_NED_IS_EXTENDED (0)
#define CAN1_SBG_ECAN_MSG_EKF_POS_ACC_IS_EXTENDED (0)
#define CAN1_SBG_ECAN_MSG_EKF_POS_IS_EXTENDED (0)
#define CAN1_SBG_ECAN_MSG_EKF_ORIENTATION_ACC_IS_EXTENDED (0)
#define CAN1_SBG_ECAN_MSG_EKF_EULER_IS_EXTENDED (0)
#define CAN1_SBG_ECAN_MSG_EKF_QUAT_IS_EXTENDED (0)
#define CAN1_SBG_ECAN_MSG_EKF_INFO_IS_EXTENDED (0)
#define CAN1_SBG_ECAN_MSG_IMU_DELTA_ANGLE_IS_EXTENDED (0)
#define CAN1_SBG_ECAN_MSG_IMU_DELTA_VEL_IS_EXTENDED (0)
#define CAN1_SBG_ECAN_MSG_IMU_GYRO_IS_EXTENDED (0)
#define CAN1_SBG_ECAN_MSG_IMU_ACCEL_IS_EXTENDED (0)
#define CAN1_SBG_ECAN_MSG_IMU_INFO_IS_EXTENDED (0)
#define CAN1_SBG_ECAN_MSG_UTC_1_IS_EXTENDED (0)
#define CAN1_SBG_ECAN_MSG_UTC_0_IS_EXTENDED (0)
#define CAN1_FS_DATALOGGER_RESERVED_6_IS_EXTENDED (0)
#define CAN1_FS_DATALOGGER_RESERVED_5_IS_EXTENDED (0)
#define CAN1_FS_DATALOGGER_RESERVED_4_IS_EXTENDED (0)
#define CAN1_FS_DATALOGGER_RESERVED_3_IS_EXTENDED (0)
#define CAN1_FS_DATALOGGER_RESERVED_2_IS_EXTENDED (0)
#define CAN1_FS_DATALOGGER_RESERVED_1_IS_EXTENDED (0)
#define CAN1_FS_DATALOGGER_STATUS_IS_EXTENDED (0)
#define CAN1_VESC_STATUS_2_IS_EXTENDED (1)
#define CAN1_VESC_STATUS_4_IS_EXTENDED (1)
#define CAN1_VESC_STATUS_5_IS_EXTENDED (1)
#define CAN1_VESC_STATUS_6_IS_EXTENDED (1)
#define CAN1_VESC_SET_DUTY_IS_EXTENDED (1)
#define CAN1_VESC_STATUS_IS_EXTENDED (1)
#define CAN1_AMS_S1_VOLTAGES_1_IS_EXTENDED (0)
#define CAN1_AMS_S1_VOLTAGES_2_IS_EXTENDED (0)
#define CAN1_AMS_S2_VOLTAGES_1_IS_EXTENDED (0)
#define CAN1_AMS_S2_VOLTAGES_2_IS_EXTENDED (0)
#define CAN1_AMS_S3_VOLTAGES_1_IS_EXTENDED (0)
#define CAN1_AMS_S3_VOLTAGES_2_IS_EXTENDED (0)
#define CAN1_AMS_S4_VOLTAGES_1_IS_EXTENDED (0)
#define CAN1_AMS_S4_VOLTAGES_2_IS_EXTENDED (0)
#define CAN1_AMS_S5_VOLTAGES_1_IS_EXTENDED (0)
#define CAN1_AMS_S5_VOLTAGES_2_IS_EXTENDED (0)
#define CAN1_AMS_S6_VOLTAGES_1_IS_EXTENDED (0)
#define CAN1_AMS_S6_VOLTAGES_2_IS_EXTENDED (0)
#define CAN1_AMS_S7_VOLTAGES_1_IS_EXTENDED (0)
#define CAN1_AMS_S7_VOLTAGES_2_IS_EXTENDED (0)
#define CAN1_AMS_S8_VOLTAGES_1_IS_EXTENDED (0)
#define CAN1_AMS_S8_VOLTAGES_2_IS_EXTENDED (0)
#define CAN1_AMS_S9_VOLTAGES_1_IS_EXTENDED (0)
#define CAN1_AMS_S9_VOLTAGES_2_IS_EXTENDED (0)
#define CAN1_AMS_S10_VOLTAGES_1_IS_EXTENDED (0)
#define CAN1_AMS_S10_VOLTAGES_2_IS_EXTENDED (0)
#define CAN1_AMS_S11_VOLTAGES_1_IS_EXTENDED (0)
#define CAN1_AMS_S11_VOLTAGES_2_IS_EXTENDED (0)
#define CAN1_AMS_S12_VOLTAGES_1_IS_EXTENDED (0)
#define CAN1_AMS_S12_VOLTAGES_2_IS_EXTENDED (0)
#define CAN1_IVT_IMPROVED_STATUS_IS_EXTENDED (0)
#define CAN1_RES_RECIEVE_PDO_IS_EXTENDED (0)
#define CAN1_RES_TRANSMIT_SDO_IS_EXTENDED (0)
#define CAN1_RES_RECIEVE_SDO_IS_EXTENDED (0)
#define CAN1_RES_TRANSMIT_LSS_IS_EXTENDED (0)
#define CAN1_RES_RECIEVE_LSS_IS_EXTENDED (0)

/* Frame cycle times in milliseconds. */
#define CAN1_AMS_STATUS_1_CYCLE_TIME_MS (400u)
#define CAN1_AMS_STATE_CYCLE_TIME_MS (0u)
#define CAN1_AMS_ERROR_CYCLE_TIME_MS (0u)
#define CAN1_DV_DRIVING_DYNAMICS_1_CYCLE_TIME_MS (0u)
#define CAN1_DV_DRIVING_DYNAMICS_2_CYCLE_TIME_MS (0u)
#define CAN1_DV_SYSTEM_STATUS_CYCLE_TIME_MS (0u)
#define CAN1_MCU_SET_ECU_INDICATOR_POINTS_CYCLE_TIME_MS (0u)
#define CAN1_MCU_SET_DBU_INDICATOR_POINTS_CYCLE_TIME_MS (0u)
#define CAN1_RES_STATUS_CYCLE_TIME_MS (0u)
#define CAN1_RES_INITIALIZATION_CYCLE_TIME_MS (0u)
#define CAN1_RES_NMT_NODE_CONTROL_CYCLE_TIME_MS (0u)
#define CAN1_SWU_STATUS_CYCLE_TIME_MS (0u)
#define CAN1_DBU_STATUS_1_CYCLE_TIME_MS (0u)
#define CAN1_LV_POWER_SIGNAL_CYCLE_TIME_MS (0u)
#define CAN1_LV_BMS_DATA_A_CYCLE_TIME_MS (0u)
#define CAN1_LV_BMS_STATUS_A_CYCLE_TIME_MS (0u)
#define CAN1_AMS_TEMPERATURES_CYCLE_TIME_MS (1200u)
#define CAN1_AMS_CELL_VOLTAGES_CYCLE_TIME_MS (800u)
#define CAN1_AMS_CELL_TEMPERATURES_CYCLE_TIME_MS (1200u)
#define CAN1_ECU_STATUS_CYCLE_TIME_MS (0u)
#define CAN1_EBS_STATUS_CYCLE_TIME_MS (0u)
#define CAN1_DCU_PPS_CYCLE_TIME_MS (0u)
#define CAN1_DCU_STATUS_CYCLE_TIME_MS (0u)
#define CAN1_MCU_SET_CCU_COOLING_POINTS_CYCLE_TIME_MS (0u)
#define CAN1_CCU_STATUS_1_CYCLE_TIME_MS (0u)
#define CAN1_CCU_STATUS_2_CYCLE_TIME_MS (0u)
#define CAN1_VEHICLE_STATUS_CYCLE_TIME_MS (0u)
#define CAN1_FAULT_CYCLE_TIME_MS (0u)
#define CAN1_DCU_STATUS_STEERING_BRAKE_CYCLE_TIME_MS (0u)
#define CAN1_DBU_STATUS_2_CYCLE_TIME_MS (0u)
#define CAN1_DV_CONTROL_TARGET_CYCLE_TIME_MS (0u)
#define CAN1_VEHICLE_STATUS_WHEEL_SPEED_CYCLE_TIME_MS (0u)
#define CAN1_SBG_ECAN_MSG_GPS2_HDT_CYCLE_TIME_MS (0u)
#define CAN1_SBG_ECAN_MSG_GPS2_HDT_INFO_CYCLE_TIME_MS (0u)
#define CAN1_SBG_ECAN_MSG_GPS2_POS_ACC_CYCLE_TIME_MS (0u)
#define CAN1_SBG_ECAN_MSG_GPS2_POS_ALT_CYCLE_TIME_MS (0u)
#define CAN1_SBG_ECAN_MSG_GPS2_POS_CYCLE_TIME_MS (0u)
#define CAN1_SBG_ECAN_MSG_GPS2_POS_INFO_CYCLE_TIME_MS (0u)
#define CAN1_SBG_ECAN_MSG_GPS2_VEL_COURSE_CYCLE_TIME_MS (0u)
#define CAN1_SBG_ECAN_MSG_GPS2_VEL_ACC_CYCLE_TIME_MS (0u)
#define CAN1_SBG_ECAN_MSG_GPS2_VEL_CYCLE_TIME_MS (0u)
#define CAN1_SBG_ECAN_MSG_GPS2_VEL_INFO_CYCLE_TIME_MS (0u)
#define CAN1_SBG_ECAN_MSG_GPS1_HDT_CYCLE_TIME_MS (0u)
#define CAN1_SBG_ECAN_MSG_GPS1_HDT_INFO_CYCLE_TIME_MS (0u)
#define CAN1_SBG_ECAN_MSG_GPS1_POS_ACC_CYCLE_TIME_MS (0u)
#define CAN1_SBG_ECAN_MSG_GPS1_POS_ALT_CYCLE_TIME_MS (0u)
#define CAN1_SBG_ECAN_MSG_GPS1_POS_CYCLE_TIME_MS (0u)
#define CAN1_SBG_ECAN_MSG_GPS1_POS_INFO_CYCLE_TIME_MS (0u)
#define CAN1_SBG_ECAN_MSG_GPS1_VEL_COURSE_CYCLE_TIME_MS (0u)
#define CAN1_SBG_ECAN_MSG_GPS1_VEL_ACC_CYCLE_TIME_MS (0u)
#define CAN1_SBG_ECAN_MSG_GPS1_VEL_CYCLE_TIME_MS (0u)
#define CAN1_SBG_ECAN_MSG_GPS1_VEL_INFO_CYCLE_TIME_MS (0u)
#define CAN1_SBG_ECAN_MSG_ODO_VEL_CYCLE_TIME_MS (0u)
#define CAN1_SBG_ECAN_MSG_ODO_INFO_CYCLE_TIME_MS (0u)
#define CAN1_SBG_ECAN_MSG_EKF_VEL_BODY_CYCLE_TIME_MS (0u)
#define CAN1_SBG_ECAN_MSG_EKF_VEL_NED_ACC_CYCLE_TIME_MS (0u)
#define CAN1_SBG_ECAN_MSG_EKF_VEL_NED_CYCLE_TIME_MS (0u)
#define CAN1_SBG_ECAN_MSG_EKF_POS_ACC_CYCLE_TIME_MS (0u)
#define CAN1_SBG_ECAN_MSG_EKF_POS_CYCLE_TIME_MS (0u)
#define CAN1_SBG_ECAN_MSG_EKF_ORIENTATION_ACC_CYCLE_TIME_MS (0u)
#define CAN1_SBG_ECAN_MSG_EKF_EULER_CYCLE_TIME_MS (0u)
#define CAN1_SBG_ECAN_MSG_EKF_QUAT_CYCLE_TIME_MS (0u)
#define CAN1_SBG_ECAN_MSG_EKF_INFO_CYCLE_TIME_MS (0u)
#define CAN1_SBG_ECAN_MSG_IMU_DELTA_ANGLE_CYCLE_TIME_MS (0u)
#define CAN1_SBG_ECAN_MSG_IMU_DELTA_VEL_CYCLE_TIME_MS (0u)
#define CAN1_SBG_ECAN_MSG_IMU_GYRO_CYCLE_TIME_MS (0u)
#define CAN1_SBG_ECAN_MSG_IMU_ACCEL_CYCLE_TIME_MS (0u)
#define CAN1_SBG_ECAN_MSG_IMU_INFO_CYCLE_TIME_MS (0u)
#define CAN1_SBG_ECAN_MSG_UTC_1_CYCLE_TIME_MS (0u)
#define CAN1_SBG_ECAN_MSG_UTC_0_CYCLE_TIME_MS (0u)
#define CAN1_FS_DATALOGGER_RESERVED_6_CYCLE_TIME_MS (0u)
#define CAN1_FS_DATALOGGER_RESERVED_5_CYCLE_TIME_MS (0u)
#define CAN1_FS_DATALOGGER_RESERVED_4_CYCLE_TIME_MS (0u)
#define CAN1_FS_DATALOGGER_RESERVED_3_CYCLE_TIME_MS (0u)
#define CAN1_FS_DATALOGGER_RESERVED_2_CYCLE_TIME_MS (0u)
#define CAN1_FS_DATALOGGER_RESERVED_1_CYCLE_TIME_MS (0u)
#define CAN1_FS_DATALOGGER_STATUS_CYCLE_TIME_MS (0u)
#define CAN1_VESC_STATUS_2_CYCLE_TIME_MS (0u)
#define CAN1_VESC_STATUS_4_CYCLE_TIME_MS (0u)
#define CAN1_VESC_STATUS_5_CYCLE_TIME_MS (0u)
#define CAN1_VESC_STATUS_6_CYCLE_TIME_MS (0u)
#define CAN1_VESC_SET_DUTY_CYCLE_TIME_MS (0u)
#define CAN1_VESC_STATUS_CYCLE_TIME_MS (0u)
#define CAN1_AMS_S1_VOLTAGES_1_CYCLE_TIME_MS (0u)
#define CAN1_AMS_S1_VOLTAGES_2_CYCLE_TIME_MS (0u)
#define CAN1_AMS_S2_VOLTAGES_1_CYCLE_TIME_MS (0u)
#define CAN1_AMS_S2_VOLTAGES_2_CYCLE_TIME_MS (0u)
#define CAN1_AMS_S3_VOLTAGES_1_CYCLE_TIME_MS (0u)
#define CAN1_AMS_S3_VOLTAGES_2_CYCLE_TIME_MS (0u)
#define CAN1_AMS_S4_VOLTAGES_1_CYCLE_TIME_MS (0u)
#define CAN1_AMS_S4_VOLTAGES_2_CYCLE_TIME_MS (0u)
#define CAN1_AMS_S5_VOLTAGES_1_CYCLE_TIME_MS (0u)
#define CAN1_AMS_S5_VOLTAGES_2_CYCLE_TIME_MS (0u)
#define CAN1_AMS_S6_VOLTAGES_1_CYCLE_TIME_MS (0u)
#define CAN1_AMS_S6_VOLTAGES_2_CYCLE_TIME_MS (0u)
#define CAN1_AMS_S7_VOLTAGES_1_CYCLE_TIME_MS (0u)
#define CAN1_AMS_S7_VOLTAGES_2_CYCLE_TIME_MS (0u)
#define CAN1_AMS_S8_VOLTAGES_1_CYCLE_TIME_MS (0u)
#define CAN1_AMS_S8_VOLTAGES_2_CYCLE_TIME_MS (0u)
#define CAN1_AMS_S9_VOLTAGES_1_CYCLE_TIME_MS (0u)
#define CAN1_AMS_S9_VOLTAGES_2_CYCLE_TIME_MS (0u)
#define CAN1_AMS_S10_VOLTAGES_1_CYCLE_TIME_MS (0u)
#define CAN1_AMS_S10_VOLTAGES_2_CYCLE_TIME_MS (0u)
#define CAN1_AMS_S11_VOLTAGES_1_CYCLE_TIME_MS (0u)
#define CAN1_AMS_S11_VOLTAGES_2_CYCLE_TIME_MS (0u)
#define CAN1_AMS_S12_VOLTAGES_1_CYCLE_TIME_MS (0u)
#define CAN1_AMS_S12_VOLTAGES_2_CYCLE_TIME_MS (0u)
#define CAN1_IVT_IMPROVED_STATUS_CYCLE_TIME_MS (0u)
#define CAN1_RES_RECIEVE_PDO_CYCLE_TIME_MS (0u)
#define CAN1_RES_TRANSMIT_SDO_CYCLE_TIME_MS (0u)
#define CAN1_RES_RECIEVE_SDO_CYCLE_TIME_MS (0u)
#define CAN1_RES_TRANSMIT_LSS_CYCLE_TIME_MS (0u)
#define CAN1_RES_RECIEVE_LSS_CYCLE_TIME_MS (0u)

/* Signal choices. */
#define CAN1_AMS_STATUS_1_CHARGING_STATUS_IDLE_CHOICE (0u)
#define CAN1_AMS_STATUS_1_CHARGING_STATUS_CHARGING_CHOICE (1u)
#define CAN1_AMS_STATUS_1_CHARGING_STATUS_DISCHARGING_CHOICE (2u)
#define CAN1_AMS_STATUS_1_CHARGING_STATUS_FULL_CHOICE (3u)

#define CAN1_AMS_STATUS_1_AIR1_CLOSED_OPEN_CHOICE (0u)
#define CAN1_AMS_STATUS_1_AIR1_CLOSED_CLOSED_CHOICE (1u)

#define CAN1_AMS_STATUS_1_AIR2_CLOSED_OPEN_CHOICE (0u)
#define CAN1_AMS_STATUS_1_AIR2_CLOSED_CLOSED_CHOICE (1u)

#define CAN1_AMS_STATUS_1_SC_CLOSED_OPEN_CHOICE (0u)
#define CAN1_AMS_STATUS_1_SC_CLOSED_CLOSED_CHOICE (1u)

#define CAN1_AMS_STATUS_1_PRE_CHARGE_STATUS_NOT_ACTIVE_CHOICE (0u)
#define CAN1_AMS_STATUS_1_PRE_CHARGE_STATUS_ACTIVE_CHOICE (1u)

#define CAN1_AMS_STATUS_1_AMS_ERROR_OK_CHOICE (0u)
#define CAN1_AMS_STATUS_1_AMS_ERROR_ERROR_CHOICE (1u)

#define CAN1_AMS_STATUS_1_IMD_ERROR_OK_CHOICE (0u)
#define CAN1_AMS_STATUS_1_IMD_ERROR_ERROR_CHOICE (1u)

#define CAN1_AMS_STATE_STATE_AMS_BALANCE__CHOICE (0u)
#define CAN1_AMS_STATE_STATE_AMS_BALANCE_IDLE_CHOICE (1u)
#define CAN1_AMS_STATE_STATE_AMS_CHARGE__CHOICE (2u)
#define CAN1_AMS_STATE_STATE_AMS_CHARGE_CHARGE_CHOICE (3u)
#define CAN1_AMS_STATE_STATE_AMS_CHARGE_EXIT_CHOICE (4u)
#define CAN1_AMS_STATE_STATE_AMS_CHARGE_FAILED_CHOICE (5u)
#define CAN1_AMS_STATE_STATE_AMS_CHARGE_PRECHARGE_CHOICE (6u)
#define CAN1_AMS_STATE_STATE_AMS_CHARGE_START_CHARGER_CHOICE (7u)
#define CAN1_AMS_STATE_STATE_AMS_DRIVE__CHOICE (8u)
#define CAN1_AMS_STATE_STATE_AMS_DRIVE_DRIVE_CHOICE (9u)
#define CAN1_AMS_STATE_STATE_AMS_DRIVE_EXIT_CHOICE (10u)
#define CAN1_AMS_STATE_STATE_AMS_DRIVE_PRECHARGE_CHOICE (11u)
#define CAN1_AMS_STATE_STATE_AMS_MAIN__CHOICE (12u)
#define CAN1_AMS_STATE_STATE_AMS_MAIN_INIT_ADC_CHOICE (13u)
#define CAN1_AMS_STATE_STATE_AMS_MAIN_INIT_COOL_CHOICE (14u)
#define CAN1_AMS_STATE_STATE_AMS_MAIN_INIT_IVT_CHOICE (15u)
#define CAN1_AMS_STATE_STATE_AMS_MAIN_INIT_LTC_CHOICE (16u)
#define CAN1_AMS_STATE_STATE_AMS_MAIN_INIT_STATE_MACHINE_CHOICE (17u)
#define CAN1_AMS_STATE_STATE_AMS_MAIN_SAFE_STATE_CHOICE (18u)
#define CAN1_AMS_STATE_STATE_AMS_MAIN_SETUP_COMPLETE_CHOICE (19u)
#define CAN1_AMS_STATE_STATE_AMS_MAIN_WATCHDOG_CHOICE (20u)
#define CAN1_AMS_STATE_STATE_AMS_PRECHARGE__CHOICE (21u)
#define CAN1_AMS_STATE_STATE_AMS_PRECHARGE_CLOSE_AIR_MINUS_CHOICE (22u)
#define CAN1_AMS_STATE_STATE_AMS_PRECHARGE_CLOSE_AIR_PLUS_CHOICE (23u)
#define CAN1_AMS_STATE_STATE_AMS_PRECHARGE_CLOSE_PRECHARGE_CHOICE (24u)
#define CAN1_AMS_STATE_STATE_AMS_PRECHARGE_DONE_CHOICE (25u)
#define CAN1_AMS_STATE_STATE_AMS_PRECHARGE_FAILED1_CHOICE (26u)
#define CAN1_AMS_STATE_STATE_AMS_PRECHARGE_FAILED2_CHOICE (27u)
#define CAN1_AMS_STATE_STATE_AMS_PRECHARGE_FAILED3_CHOICE (28u)
#define CAN1_AMS_STATE_STATE_AMS_PRECHARGE_FAILED4_CHOICE (29u)
#define CAN1_AMS_STATE_STATE_AMS_PRECHARGE_FAILED5_CHOICE (30u)
#define CAN1_AMS_STATE_STATE_AMS_PRECHARGE_OPEN_PRECHARGE_CHOICE (31u)
#define CAN1_AMS_STATE_STATE_AMS_PRECHARGE_PRECHARGE_CHOICE (32u)
#define CAN1_AMS_STATE_STATE_AMS_STATE_MACHINE__CHOICE (33u)
#define CAN1_AMS_STATE_STATE_AMS_STATE_MACHINE_BALANCE_CHOICE (34u)
#define CAN1_AMS_STATE_STATE_AMS_STATE_MACHINE_CHARGE_CHOICE (35u)
#define CAN1_AMS_STATE_STATE_AMS_STATE_MACHINE_DRIVE_CHOICE (36u)
#define CAN1_AMS_STATE_STATE_AMS_STATE_MACHINE_IDLE_CHOICE (37u)

#define CAN1_AMS_ERROR_ERROR_UNKNOWN_ERROR_CHOICE (0u)
#define CAN1_AMS_ERROR_ERROR_PROGRAM_EXIT_CHOICE (1u)
#define CAN1_AMS_ERROR_ERROR_IMD_ERROR_CHOICE (2u)
#define CAN1_AMS_ERROR_ERROR_AMS_ERROR_CHOICE (3u)
#define CAN1_AMS_ERROR_ERROR_AIR_PLUS_RELAY_FAILED_CHOICE (4u)
#define CAN1_AMS_ERROR_ERROR_AIR_MINUS_RELAY_FAILED_CHOICE (5u)
#define CAN1_AMS_ERROR_ERROR_PRECHARGE_RELAY_FAILED_CHOICE (6u)
#define CAN1_AMS_ERROR_ERROR_PRECHARGE_TIMEOUT_CHOICE (7u)
#define CAN1_AMS_ERROR_ERROR_NO_CHARGER_CHOICE (8u)
#define CAN1_AMS_ERROR_ERROR_NO_NEW_ACCUMULATOR_VOLTAGE_CHOICE (9u)
#define CAN1_AMS_ERROR_ERROR_NO_NEW_ACCUMULATOR_CURRENT_CHOICE (10u)
#define CAN1_AMS_ERROR_ERROR_NO_NEW_INVERTER_VOLTAGE_CHOICE (11u)
#define CAN1_AMS_ERROR_ERROR_CELL_OVER_VOLTAGE_CHOICE (12u)
#define CAN1_AMS_ERROR_ERROR_CELL_UNDER_VOLTAGE_CHOICE (13u)
#define CAN1_AMS_ERROR_ERROR_CELL_OVER_TEMPERATURE_CHOICE (14u)
#define CAN1_AMS_ERROR_ERROR_CELL_UNDER_TEMPERATURE_CHOICE (15u)
#define CAN1_AMS_ERROR_ERROR_ACCUMULATOR_OVER_VOLTAGE_CHOICE (16u)
#define CAN1_AMS_ERROR_ERROR_ACCUMULATOR_UNDER_VOLTAGE_CHOICE (17u)
#define CAN1_AMS_ERROR_ERROR_ACCUMULATOR_OVER_CURRENT_CHOICE (18u)
#define CAN1_AMS_ERROR_ERROR_ACCUMULATOR_UNDER_CURRENT_CHOICE (19u)

#define CAN1_DV_SYSTEM_STATUS_AS_STATE_OFF_CHOICE (1u)
#define CAN1_DV_SYSTEM_STATUS_AS_STATE_READY_CHOICE (2u)
#define CAN1_DV_SYSTEM_STATUS_AS_STATE_DRIVING_CHOICE (3u)
#define CAN1_DV_SYSTEM_STATUS_AS_STATE_EMERGENCY_BRAKE_CHOICE (4u)
#define CAN1_DV_SYSTEM_STATUS_AS_STATE_FINISH_CHOICE (5u)

#define CAN1_DV_SYSTEM_STATUS_EBS_STATE_UNAVAILABLE_CHOICE (1u)
#define CAN1_DV_SYSTEM_STATUS_EBS_STATE_ARMED_CHOICE (2u)
#define CAN1_DV_SYSTEM_STATUS_EBS_STATE_ACTIVATED_CHOICE (3u)

#define CAN1_DV_SYSTEM_STATUS_AMI_STATE_ACCELERATION_CHOICE (1u)
#define CAN1_DV_SYSTEM_STATUS_AMI_STATE_SKIDPAD_CHOICE (2u)
#define CAN1_DV_SYSTEM_STATUS_AMI_STATE_TRACKDRIVE_CHOICE (3u)
#define CAN1_DV_SYSTEM_STATUS_AMI_STATE_BRAKETEST_CHOICE (4u)
#define CAN1_DV_SYSTEM_STATUS_AMI_STATE_INSPECTION_CHOICE (5u)
#define CAN1_DV_SYSTEM_STATUS_AMI_STATE_AUTOCROSS_CHOICE (6u)
#define CAN1_DV_SYSTEM_STATUS_AMI_STATE_MANUAL_DRIVING_CHOICE (7u)

#define CAN1_DV_SYSTEM_STATUS_SERVICE_BRAKE_STATE_DISENGAGED_CHOICE (1u)
#define CAN1_DV_SYSTEM_STATUS_SERVICE_BRAKE_STATE_ENGAGED_CHOICE (2u)
#define CAN1_DV_SYSTEM_STATUS_SERVICE_BRAKE_STATE_AVAILABLE_CHOICE (3u)

#define CAN1_RES_STATUS_E_STOP_E_STOP_OK_CHOICE (0u)
#define CAN1_RES_STATUS_E_STOP_E_STOP_ACTIVE_CHOICE (1u)

#define CAN1_RES_STATUS_SWITCH_STATUS_LOW_CHOICE (0u)
#define CAN1_RES_STATUS_SWITCH_STATUS_HIGH_CHOICE (1u)

#define CAN1_RES_STATUS_BUTTON_STATUS_LOW_CHOICE (0u)
#define CAN1_RES_STATUS_BUTTON_STATUS_HIGH_CHOICE (1u)

#define CAN1_RES_STATUS_E_STOP_REDUNDANCY_E_STOP_OK_CHOICE (0u)
#define CAN1_RES_STATUS_E_STOP_REDUNDANCY_E_STOP_ACTIVE_CHOICE (1u)

#define CAN1_DBU_STATUS_1_SELECTED_MISSION_NO_MISSION_SELECTED_CHOICE (0u)
#define CAN1_DBU_STATUS_1_SELECTED_MISSION_AS_ACCELERATION_SELECTED_CHOICE (1u)
#define CAN1_DBU_STATUS_1_SELECTED_MISSION_AS_SKIDPAD_SELECTED_CHOICE (2u)
#define CAN1_DBU_STATUS_1_SELECTED_MISSION_AS_TRACKDRIVE_SELECTED_CHOICE (3u)
#define CAN1_DBU_STATUS_1_SELECTED_MISSION_AS_BRAKETEST_SELECTED_CHOICE (4u)
#define CAN1_DBU_STATUS_1_SELECTED_MISSION_AS_INSPECTION_SELECTED_CHOICE (5u)
#define CAN1_DBU_STATUS_1_SELECTED_MISSION_AS_AUTOCROSS_SELECTED_CHOICE (6u)
#define CAN1_DBU_STATUS_1_SELECTED_MISSION_MANUAL_DRIVING_SELECTED_CHOICE (7u)

#define CAN1_LV_BMS_STATUS_A_LV_BMS_ERROR_NO_ERROR_CHOICE (0u)
#define CAN1_LV_BMS_STATUS_A_LV_BMS_ERROR_CELL_OVER_VOLTAGE_CHOICE (1u)
#define CAN1_LV_BMS_STATUS_A_LV_BMS_ERROR_CELL_UNDER_VOLTAGE_CHOICE (2u)
#define CAN1_LV_BMS_STATUS_A_LV_BMS_ERROR_OVER_TEMPERATURE_CHOICE (3u)
#define CAN1_LV_BMS_STATUS_A_LV_BMS_ERROR_UNDER_TEMPERATURE_CHOICE (4u)
#define CAN1_LV_BMS_STATUS_A_LV_BMS_ERROR_OVER_CURRENT_CHOICE (5u)
#define CAN1_LV_BMS_STATUS_A_LV_BMS_ERROR_UNDER_CURRENT_CHOICE (6u)
#define CAN1_LV_BMS_STATUS_A_LV_BMS_ERROR_ADC_TIMEOUT_CHOICE (7u)

#define CAN1_ECU_STATUS_TS_NOT_OFF_TS_OFF_CHOICE (0u)
#define CAN1_ECU_STATUS_TS_NOT_OFF_TS_ON_CHOICE (1u)

#define CAN1_ECU_STATUS_RST_BUTTON_RELEASED_CHOICE (0u)
#define CAN1_ECU_STATUS_RST_BUTTON_PUSHED_CHOICE (1u)

#define CAN1_ECU_STATUS_CLOSE_AIRS_RELEASED_CHOICE (0u)
#define CAN1_ECU_STATUS_CLOSE_AIRS_PUSHED_CHOICE (1u)

#define CAN1_ECU_STATUS_TS_OFF_TS_ON_CHOICE (0u)
#define CAN1_ECU_STATUS_TS_OFF_TS_OFF_CHOICE (1u)

#define CAN1_EBS_STATUS_SC_TSMS_STATUS_CLOSED_CHOICE (0u)
#define CAN1_EBS_STATUS_SC_TSMS_STATUS_OPEN_CHOICE (1u)

#define CAN1_EBS_STATUS_RES_OPEN_CLOSED_CHOICE (0u)
#define CAN1_EBS_STATUS_RES_OPEN_OPEN_CHOICE (1u)

#define CAN1_EBS_STATUS_EBS_STATUS_EBS_UNAVAILABLE_CHOICE (1u)
#define CAN1_EBS_STATUS_EBS_STATUS_EBS_ARMED_CHOICE (2u)
#define CAN1_EBS_STATUS_EBS_STATUS_EBS_ACTIVATED_CHOICE (3u)

#define CAN1_EBS_STATUS_EBS_STATE_MACHINE_EBS_WAIT_MISSION_CHOICE (0u)
#define CAN1_EBS_STATUS_EBS_STATE_MACHINE_EBS_WAIT_TANK_CHOICE (1u)
#define CAN1_EBS_STATUS_EBS_STATE_MACHINE_EBS_START_SDC_WDT_CHOICE (2u)
#define CAN1_EBS_STATUS_EBS_STATE_MACHINE_EBS_STOP_SDC_WDT_CHOICE (3u)
#define CAN1_EBS_STATUS_EBS_STATE_MACHINE_EBS_WAIT_EBS_POWER_CHOICE (4u)
#define CAN1_EBS_STATUS_EBS_STATE_MACHINE_EBS_TEST_EBS_CHOICE (5u)
#define CAN1_EBS_STATUS_EBS_STATE_MACHINE_EBS_ARMED_CHOICE (6u)
#define CAN1_EBS_STATUS_EBS_STATE_MACHINE_EBS_UNAVAILABLE_CHOICE (7u)
#define CAN1_EBS_STATUS_EBS_STATE_MACHINE_EBS_FAULT_CHOICE (8u)

#define CAN1_EBS_STATUS_EBS_ERROR_NO_ERROR_CHOICE (0u)
#define CAN1_EBS_STATUS_EBS_ERROR_CAN_TIMEOUT_ERROR_CHOICE (1u)
#define CAN1_EBS_STATUS_EBS_ERROR_TIMEOUT_ERROR_CHOICE (2u)
#define CAN1_EBS_STATUS_EBS_ERROR_AS_EMERGENCY_ERROR_CHOICE (3u)
#define CAN1_EBS_STATUS_EBS_ERROR_LOW_TANK_PRESSURE_CHOICE (4u)
#define CAN1_EBS_STATUS_EBS_ERROR_NO_EBS_POWER_CHOICE (5u)
#define CAN1_EBS_STATUS_EBS_ERROR_SDC_OPEN_CHOICE (6u)
#define CAN1_EBS_STATUS_EBS_ERROR_GENERAL_ERROR_CHOICE (7u)

#define CAN1_VEHICLE_STATUS_CAR_STATE_CAR_OFF_CHOICE (0u)

#define CAN1_DV_CONTROL_TARGET_DV_MISSION_STATUS_ACCELERATION_CHOICE (1u)
#define CAN1_DV_CONTROL_TARGET_DV_MISSION_STATUS_SKIDPAD_CHOICE (2u)
#define CAN1_DV_CONTROL_TARGET_DV_MISSION_STATUS_TRACKDRIVE_CHOICE (3u)
#define CAN1_DV_CONTROL_TARGET_DV_MISSION_STATUS_BRAKETEST_CHOICE (4u)
#define CAN1_DV_CONTROL_TARGET_DV_MISSION_STATUS_INSPECTION_CHOICE (5u)
#define CAN1_DV_CONTROL_TARGET_DV_MISSION_STATUS_AUTOCROSS_CHOICE (6u)
#define CAN1_DV_CONTROL_TARGET_DV_MISSION_STATUS_MISSION__FINISHED_CHOICE (7u)

/**
 * Signals in message ams_status_1.
 *
 * Used for DBU hardware IO.
 *
 * All signal values are as on the CAN bus.
 */
struct can1_ams_status_1_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t charging_status;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t air1_closed;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t air2_closed;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t sc_closed;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t pre_charge_status;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t ams_error;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t imd_error;

    /**
     * Range: 0..100 (0..100 %)
     * Scale: 1
     * Offset: 0
     */
    uint8_t state_of_charge;

    /**
     * Range: 0..255.1020408163265306122448980 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t min_cell_voltage;

    /**
     * Range: 0..255.1020408163265306122448980 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t max_cell_voltage;

    /**
     * Range: 0..4095.004095004095004095004095 (-10..190 C)
     * Scale: 0.04884
     * Offset: -10
     */
    int16_t min_cell_temperature;

    /**
     * Range: 0..4095.004095004095004095004095 (-10..190 C)
     * Scale: 0.04884
     * Offset: -10
     */
    int16_t max_cell_temperature;

    /**
     * Range: 0..100 (0..100 %)
     * Scale: 1
     * Offset: 0
     */
    uint8_t fan_speed;
};

/**
 * Signals in message ams_state.
 *
 * All signal values are as on the CAN bus.
 */
struct can1_ams_state_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint64_t state;
};

/**
 * Signals in message ams_error.
 *
 * All signal values are as on the CAN bus.
 */
struct can1_ams_error_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint32_t error;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint32_t reset_cause;
};

/**
 * Signals in message dv_driving_dynamics_1.
 *
 * Required by FSG.
 *
 * All signal values are as on the CAN bus.
 */
struct can1_dv_driving_dynamics_1_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t speed_actual;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t speed_target;

    /**
     * Range: -
     * Scale: 0.5
     * Offset: 0
     */
    int8_t steering_angle_actual;

    /**
     * Range: -
     * Scale: 0.5
     * Offset: 0
     */
    int8_t steering_angle_target;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t brake_hydr_actual;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t brake_hydr_target;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    int8_t motor_moment_actual;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    int8_t motor_moment_target;
};

/**
 * Signals in message dv_driving_dynamics_2.
 *
 * Required by FSG.
 *
 * All signal values are as on the CAN bus.
 */
struct can1_dv_driving_dynamics_2_t {
    /**
     * Range: -
     * Scale: 0.001953125
     * Offset: 0
     */
    int16_t acceleration_longitudinal;

    /**
     * Range: -
     * Scale: 0.001953125
     * Offset: 0
     */
    int16_t acceleration_lateral;

    /**
     * Range: -
     * Scale: 0.0078125
     * Offset: 0
     */
    int16_t yaw_rate;
};

/**
 * Signals in message dv_system_status.
 *
 * Required by FSG.
 *
 * All signal values are as on the CAN bus.
 */
struct can1_dv_system_status_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t as_state;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t ebs_state;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t ami_state;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t steering_state;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t service_brake_state;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t lap_counter;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t cones_count_actual;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint32_t cones_count_all;
};

/**
 * Signals in message mcu_set_ecu_indicator_points.
 *
 * All signal values are as on the CAN bus.
 */
struct can1_mcu_set_ecu_indicator_points_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t brake_light;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t r2d_sound;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t assi_yellow_right;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t assi_yellow_left;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t assi_yellow_rear;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t assi_blue_right;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t assi_blue_left;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t assi_blue_rear;
};

/**
 * Signals in message mcu_set_dbu_indicator_points.
 *
 * All signal values are as on the CAN bus.
 */
struct can1_mcu_set_dbu_indicator_points_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t ts_indicator_on;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t r2d_indicator_on;
};

/**
 * Signals in message res_status.
 *
 * All signal values are as on the CAN bus.
 */
struct can1_res_status_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t e_stop;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t switch_status;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t button_status;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t e_stop_redundancy;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t radio_quality;

    /**
     * pre-alarm radio communication interruption (200 ms in advance to shutdown)
     *
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t radio_state;
};

/**
 * Signals in message res_initialization.
 *
 * All signal values are as on the CAN bus.
 */
struct can1_res_initialization_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t res_init;
};

/**
 * Signals in message res_nmt_node_control.
 *
 * All signal values are as on the CAN bus.
 */
struct can1_res_nmt_node_control_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t requested_state;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t node_id;
};

/**
 * Signals in message swu_status.
 *
 * All signal values are as on the CAN bus.
 */
struct can1_swu_status_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t button_1;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t button_2;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t button_3;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t button_4;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t button_5;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t button_6;

    /**
     * Range: 0..7 (0..7 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t rotary_switch_1;

    /**
     * Range: 0..7 (0..7 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t rotary_switch_2;

    /**
     * Range: 0..7 (0..7 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t rotary_switch_3;

    /**
     * Range: 0..7 (0..7 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t rotary_switch_4;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t encoder_1_button;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t encoder_2_button;

    /**
     * Range: -128..127 (-128..127 -)
     * Scale: 1
     * Offset: 0
     */
    int8_t encoder_1;

    /**
     * Range: -128..127 (-128..127 -)
     * Scale: 1
     * Offset: 0
     */
    int8_t encoder_2;
};

/**
 * Signals in message dbu_status_1.
 *
 * All signal values are as on the CAN bus.
 */
struct can1_dbu_status_1_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t activate_ts_button;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t ready_to_drive_button;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t selected_mission;

    /**
     * Range: 0..4095.004095004095004095004095 (-10..190 C)
     * Scale: 0.04884
     * Offset: -10
     */
    int16_t dbu_temperature;
};

/**
 * Signals in message lv_power_signal.
 *
 * All signal values are as on the CAN bus.
 */
struct can1_lv_power_signal_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t lv_on;
};

/**
 * Signals in message lv_bms_data_a.
 *
 * All signal values are as on the CAN bus.
 */
struct can1_lv_bms_data_a_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t data_multiplexor;

    /**
     * Range: 0..255.0044625780951166645416295 (2.5..4.5 V)
     * Scale: 0.007843
     * Offset: 2.5
     */
    uint8_t voltage_cell_1;

    /**
     * Range: 0..100 (0..100 %)
     * Scale: 1
     * Offset: 0
     */
    uint8_t soc_1;

    /**
     * Range: 0..4095.004095004095004095004095 (-10..190 C)
     * Scale: 0.04884
     * Offset: -10
     */
    int16_t therm1;

    /**
     * Range: 0..4095.004095004095004095004095 (0..20 A)
     * Scale: 0.004884
     * Offset: 0
     */
    uint16_t current;

    /**
     * Range: 0..255.0044625780951166645416295 (2.5..4.5 V)
     * Scale: 0.007843
     * Offset: 2.5
     */
    uint8_t voltage_cell_2;

    /**
     * Range: 0..100 (0..100 %)
     * Scale: 1
     * Offset: 0
     */
    uint8_t soc_2;

    /**
     * Range: 0..4095.004095004095004095004095 (-10..190 C)
     * Scale: 0.04884
     * Offset: -10
     */
    int16_t therm2;

    /**
     * Range: 0..16777291.34303064538906934049 (0..356400 As)
     * Scale: 0.021243
     * Offset: 0
     */
    uint32_t current_count;

    /**
     * Range: 0..255.0044625780951166645416295 (2.5..4.5 V)
     * Scale: 0.007843
     * Offset: 2.5
     */
    uint8_t voltage_cell_3;

    /**
     * Range: 0..100 (0..100 %)
     * Scale: 1
     * Offset: 0
     */
    uint8_t soc_3;

    /**
     * Range: 0..255.0044625780951166645416295 (2.5..4.5 V)
     * Scale: 0.007843
     * Offset: 2.5
     */
    uint8_t voltage_cell_4;

    /**
     * Range: 0..100 (0..100 %)
     * Scale: 1
     * Offset: 0
     */
    uint8_t soc_4;

    /**
     * Range: 0..4095.004095004095004095004095 (-10..190 C)
     * Scale: 0.04884
     * Offset: -10
     */
    int16_t therm3;

    /**
     * Range: 0..255.0044625780951166645416295 (2.5..4.5 V)
     * Scale: 0.007843
     * Offset: 2.5
     */
    uint8_t voltage_cell_5;

    /**
     * Range: 0..100 (0..100 %)
     * Scale: 1
     * Offset: 0
     */
    uint8_t soc_5;

    /**
     * Range: 0..4095.004095004095004095004095 (-10..190 C)
     * Scale: 0.04884
     * Offset: -10
     */
    int16_t therm4;

    /**
     * Range: 0..16777272.97607969784881493240 (0..1532520 Ws)
     * Scale: 0.091345
     * Offset: 0
     */
    uint32_t energy_count;

    /**
     * Range: 0..255.0044625780951166645416295 (2.5..4.5 V)
     * Scale: 0.007843
     * Offset: 2.5
     */
    uint8_t voltage_cell_6;

    /**
     * Range: 0..100 (0..100 %)
     * Scale: 1
     * Offset: 0
     */
    uint8_t soc_6;

    /**
     * Range: 0..4095.004095004095004095004095 (-10..190 C)
     * Scale: 0.04884
     * Offset: -10
     */
    int16_t therm5;
};

/**
 * Signals in message lv_bms_status_a.
 *
 * All signal values are as on the CAN bus.
 */
struct can1_lv_bms_status_a_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t lv_bms_error;

    /**
     * Range: 0..100 (0..100 %)
     * Scale: 1
     * Offset: 0
     */
    uint8_t soc;

    /**
     * Range: 0..4095.004095004095004095004095 (0..20 A)
     * Scale: 0.004884
     * Offset: 0
     */
    uint16_t current;

    /**
     * Range: 0..4095.004095004095004095004095 (15..30 V)
     * Scale: 0.003663
     * Offset: 15
     */
    uint16_t voltage;

    /**
     * Range: 0..4095.004095004095004095004095 (-10..190 C)
     * Scale: 0.04884
     * Offset: -10
     */
    int16_t temperature;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t not_battery_output_enable;
};

/**
 * Signals in message ams_temperatures.
 *
 * All signal values are as on the CAN bus.
 */
struct can1_ams_temperatures_t {
    /**
     * Range: 0..4095.004095004095004095004095 (-10..190 C)
     * Scale: 0.04884
     * Offset: -10
     */
    int16_t pre_charge_resistor_temperature;

    /**
     * Range: 0..4095.004095004095004095004095 (-10..190 C)
     * Scale: 0.04884
     * Offset: -10
     */
    int16_t fuse_resistor_temperature;

    /**
     * Range: 0..4095.004095004095004095004095 (-10..190 C)
     * Scale: 0.04884
     * Offset: -10
     */
    int16_t aux_1_temperature;

    /**
     * Range: 0..4095.004095004095004095004095 (-10..190 C)
     * Scale: 0.04884
     * Offset: -10
     */
    int16_t aux_2_temperature;
};

/**
 * Signals in message ams_cell_voltages.
 *
 * All signal values are as on the CAN bus.
 */
struct can1_ams_cell_voltages_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t voltage_multiplexor;

    /**
     * Range: 0..255.1020408163265306122448980 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t v1s1;

    /**
     * Range: 0..255.1020408163265306122448980 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t v7s1;

    /**
     * Range: 0..255.1020408163265306122448980 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t v1s2;

    /**
     * Range: 0..255.1020408163265306122448980 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t v7s2;

    /**
     * Range: 0..255.1020408163265306122448980 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t v1s3;

    /**
     * Range: 0..255.1020408163265306122448980 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t v7s3;

    /**
     * Range: 0..255.1020408163265306122448980 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t v1s4;

    /**
     * Range: 0..255.1020408163265306122448980 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t v7s4;

    /**
     * Range: 0..255.1020408163265306122448980 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t v1s5;

    /**
     * Range: 0..255.1020408163265306122448980 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t v7s5;

    /**
     * Range: 0..255.1020408163265306122448980 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t v1s6;

    /**
     * Range: 0..255.1020408163265306122448980 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t v7s6;

    /**
     * Range: 0..255.1020408163265306122448980 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t v1s7;

    /**
     * Range: 0..255.1020408163265306122448980 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t v7s7;

    /**
     * Range: 0..255.1020408163265306122448980 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t v1s8;

    /**
     * Range: 0..255.1020408163265306122448980 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t v7s8;

    /**
     * Range: 0..255.1020408163265306122448980 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t v1s9;

    /**
     * Range: 0..255.1020408163265306122448980 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t v7s9;

    /**
     * Range: 0..255.1020408163265306122448980 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t v1s10;

    /**
     * Range: 0..255.1020408163265306122448980 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t v7s10;

    /**
     * Range: 0..255.1020408163265306122448980 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t v1s11;

    /**
     * Range: 0..255.1020408163265306122448980 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t v7s11;

    /**
     * Range: 0..255.1020408163265306122448980 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t v1s12;

    /**
     * Range: 0..255.1020408163265306122448980 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t v7s12;

    /**
     * Range: 0..255.1020408163265306122448980 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t v2s1;

    /**
     * Range: 0..255.1020408163265306122448980 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t v8s1;

    /**
     * Range: 0..255.1020408163265306122448980 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t v2s2;

    /**
     * Range: 0..255.1020408163265306122448980 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t v8s2;

    /**
     * Range: 0..255.1020408163265306122448980 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t v2s3;

    /**
     * Range: 0..255.1020408163265306122448980 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t v8s3;

    /**
     * Range: 0..255.1020408163265306122448980 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t v2s4;

    /**
     * Range: 0..255.1020408163265306122448980 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t v8s4;

    /**
     * Range: 0..255.1020408163265306122448980 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t v2s5;

    /**
     * Range: 0..255.1020408163265306122448980 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t v8s5;

    /**
     * Range: 0..255.1020408163265306122448980 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t v2s6;

    /**
     * Range: 0..255.1020408163265306122448980 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t v8s6;

    /**
     * Range: 0..255.1020408163265306122448980 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t v2s7;

    /**
     * Range: 0..255.1020408163265306122448980 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t v8s7;

    /**
     * Range: 0..255.1020408163265306122448980 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t v2s8;

    /**
     * Range: 0..255.1020408163265306122448980 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t v8s8;

    /**
     * Range: 0..255.1020408163265306122448980 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t v2s9;

    /**
     * Range: 0..255.1020408163265306122448980 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t v8s9;

    /**
     * Range: 0..255.1020408163265306122448980 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t v2s10;

    /**
     * Range: 0..255.1020408163265306122448980 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t v8s10;

    /**
     * Range: 0..255.1020408163265306122448980 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t v2s11;

    /**
     * Range: 0..255.1020408163265306122448980 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t v8s11;

    /**
     * Range: 0..255.1020408163265306122448980 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t v2s12;

    /**
     * Range: 0..255.1020408163265306122448980 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t v8s12;

    /**
     * Range: 0..255.1020408163265306122448980 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t v3s1;

    /**
     * Range: 0..255.1020408163265306122448980 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t v9s1;

    /**
     * Range: 0..255.1020408163265306122448980 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t v3s2;

    /**
     * Range: 0..255.1020408163265306122448980 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t v9s2;

    /**
     * Range: 0..255.1020408163265306122448980 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t v3s3;

    /**
     * Range: 0..255.1020408163265306122448980 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t v9s3;

    /**
     * Range: 0..255.1020408163265306122448980 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t v3s4;

    /**
     * Range: 0..255.1020408163265306122448980 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t v9s4;

    /**
     * Range: 0..255.1020408163265306122448980 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t v3s5;

    /**
     * Range: 0..255.1020408163265306122448980 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t v9s5;

    /**
     * Range: 0..255.1020408163265306122448980 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t v3s6;

    /**
     * Range: 0..255.1020408163265306122448980 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t v9s6;

    /**
     * Range: 0..255.1020408163265306122448980 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t v3s7;

    /**
     * Range: 0..255.1020408163265306122448980 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t v9s7;

    /**
     * Range: 0..255.1020408163265306122448980 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t v3s8;

    /**
     * Range: 0..255.1020408163265306122448980 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t v9s8;

    /**
     * Range: 0..255.1020408163265306122448980 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t v3s9;

    /**
     * Range: 0..255.1020408163265306122448980 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t v9s9;

    /**
     * Range: 0..255.1020408163265306122448980 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t v3s10;

    /**
     * Range: 0..255.1020408163265306122448980 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t v9s10;

    /**
     * Range: 0..255.1020408163265306122448980 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t v3s11;

    /**
     * Range: 0..255.1020408163265306122448980 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t v9s11;

    /**
     * Range: 0..255.1020408163265306122448980 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t v3s12;

    /**
     * Range: 0..255.1020408163265306122448980 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t v9s12;

    /**
     * Range: 0..255.1020408163265306122448980 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t v4s1;

    /**
     * Range: 0..255.1020408163265306122448980 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t v10s1;

    /**
     * Range: 0..255.1020408163265306122448980 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t v4s2;

    /**
     * Range: 0..255.1020408163265306122448980 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t v10s2;

    /**
     * Range: 0..255.1020408163265306122448980 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t v4s3;

    /**
     * Range: 0..255.1020408163265306122448980 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t v10s3;

    /**
     * Range: 0..255.1020408163265306122448980 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t v4s4;

    /**
     * Range: 0..255.1020408163265306122448980 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t v10s4;

    /**
     * Range: 0..255.1020408163265306122448980 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t v4s5;

    /**
     * Range: 0..255.1020408163265306122448980 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t v10s5;

    /**
     * Range: 0..255.1020408163265306122448980 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t v4s6;

    /**
     * Range: 0..255.1020408163265306122448980 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t v10s6;

    /**
     * Range: 0..255.1020408163265306122448980 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t v4s7;

    /**
     * Range: 0..255.1020408163265306122448980 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t v10s7;

    /**
     * Range: 0..255.1020408163265306122448980 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t v4s8;

    /**
     * Range: 0..255.1020408163265306122448980 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t v10s8;

    /**
     * Range: 0..255.1020408163265306122448980 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t v4s9;

    /**
     * Range: 0..255.1020408163265306122448980 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t v10s9;

    /**
     * Range: 0..255.1020408163265306122448980 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t v4s10;

    /**
     * Range: 0..255.1020408163265306122448980 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t v10s10;

    /**
     * Range: 0..255.1020408163265306122448980 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t v4s11;

    /**
     * Range: 0..255.1020408163265306122448980 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t v10s11;

    /**
     * Range: 0..255.1020408163265306122448980 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t v4s12;

    /**
     * Range: 0..255.1020408163265306122448980 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t v10s12;

    /**
     * Range: 0..255.1020408163265306122448980 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t v5s1;

    /**
     * Range: 0..255.1020408163265306122448980 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t v11s1;

    /**
     * Range: 0..255.1020408163265306122448980 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t v5s2;

    /**
     * Range: 0..255.1020408163265306122448980 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t v5s3;

    /**
     * Range: 0..255.1020408163265306122448980 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t v11s3;

    /**
     * Range: 0..255.1020408163265306122448980 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t v5s4;

    /**
     * Range: 0..255.1020408163265306122448980 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t v5s5;

    /**
     * Range: 0..255.1020408163265306122448980 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t v11s5;

    /**
     * Range: 0..255.1020408163265306122448980 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t v5s6;

    /**
     * Range: 0..255.1020408163265306122448980 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t v5s7;

    /**
     * Range: 0..255.1020408163265306122448980 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t v11s7;

    /**
     * Range: 0..255.1020408163265306122448980 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t v5s8;

    /**
     * Range: 0..255.1020408163265306122448980 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t v5s9;

    /**
     * Range: 0..255.1020408163265306122448980 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t v11s9;

    /**
     * Range: 0..255.1020408163265306122448980 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t v5s10;

    /**
     * Range: 0..255.1020408163265306122448980 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t v5s11;

    /**
     * Range: 0..255.1020408163265306122448980 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t v11s11;

    /**
     * Range: 0..255.1020408163265306122448980 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t v5s12;

    /**
     * Range: 0..255.1020408163265306122448980 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t v6s1;

    /**
     * Range: 0..255.1020408163265306122448980 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t v6s2;

    /**
     * Range: 0..255.1020408163265306122448980 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t v6s3;

    /**
     * Range: 0..255.1020408163265306122448980 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t v6s4;

    /**
     * Range: 0..255.1020408163265306122448980 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t v6s5;

    /**
     * Range: 0..255.1020408163265306122448980 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t v6s6;

    /**
     * Range: 0..255.1020408163265306122448980 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t v6s7;

    /**
     * Range: 0..255.1020408163265306122448980 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t v6s8;

    /**
     * Range: 0..255.1020408163265306122448980 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t v6s9;

    /**
     * Range: 0..255.1020408163265306122448980 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t v6s10;

    /**
     * Range: 0..255.1020408163265306122448980 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t v6s11;

    /**
     * Range: 0..255.1020408163265306122448980 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t v6s12;
};

/**
 * Signals in message ams_cell_temperatures.
 *
 * All signal values are as on the CAN bus.
 */
struct can1_ams_cell_temperatures_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t temperature_multiplexor;

    /**
     * Range: 0..4095.004095004095004095004095 (-10..190 C)
     * Scale: 0.04884
     * Offset: -10
     */
    int16_t t1s1;

    /**
     * Range: 0..4095.004095004095004095004095 (-10..190 C)
     * Scale: 0.04884
     * Offset: -10
     */
    int16_t t1s2;

    /**
     * Range: 0..4095.004095004095004095004095 (-10..190 C)
     * Scale: 0.04884
     * Offset: -10
     */
    int16_t t1s3;

    /**
     * Range: 0..4095.004095004095004095004095 (-10..190 C)
     * Scale: 0.04884
     * Offset: -10
     */
    int16_t t1s4;

    /**
     * Range: 0..4095.004095004095004095004095 (-10..190 C)
     * Scale: 0.04884
     * Offset: -10
     */
    int16_t t1s5;

    /**
     * Range: 0..4095.004095004095004095004095 (-10..190 C)
     * Scale: 0.04884
     * Offset: -10
     */
    int16_t t1s6;

    /**
     * Range: 0..4095.004095004095004095004095 (-10..190 C)
     * Scale: 0.04884
     * Offset: -10
     */
    int16_t t1s7;

    /**
     * Range: 0..4095.004095004095004095004095 (-10..190 C)
     * Scale: 0.04884
     * Offset: -10
     */
    int16_t t1s8;

    /**
     * Range: 0..4095.004095004095004095004095 (-10..190 C)
     * Scale: 0.04884
     * Offset: -10
     */
    int16_t t1s9;

    /**
     * Range: 0..4095.004095004095004095004095 (-10..190 C)
     * Scale: 0.04884
     * Offset: -10
     */
    int16_t t1s10;

    /**
     * Range: 0..4095.004095004095004095004095 (-10..190 C)
     * Scale: 0.04884
     * Offset: -10
     */
    int16_t t1s11;

    /**
     * Range: 0..4095.004095004095004095004095 (-10..190 C)
     * Scale: 0.04884
     * Offset: -10
     */
    int16_t t1s12;

    /**
     * Range: 0..4095.004095004095004095004095 (-10..190 C)
     * Scale: 0.04884
     * Offset: -10
     */
    int16_t t2s1;

    /**
     * Range: 0..4095.004095004095004095004095 (-10..190 C)
     * Scale: 0.04884
     * Offset: -10
     */
    int16_t t2s2;

    /**
     * Range: 0..4095.004095004095004095004095 (-10..190 C)
     * Scale: 0.04884
     * Offset: -10
     */
    int16_t t2s3;

    /**
     * Range: 0..4095.004095004095004095004095 (-10..190 C)
     * Scale: 0.04884
     * Offset: -10
     */
    int16_t t2s4;

    /**
     * Range: 0..4095.004095004095004095004095 (-10..190 C)
     * Scale: 0.04884
     * Offset: -10
     */
    int16_t t2s5;

    /**
     * Range: 0..4095.004095004095004095004095 (-10..190 C)
     * Scale: 0.04884
     * Offset: -10
     */
    int16_t t2s6;

    /**
     * Range: 0..4095.004095004095004095004095 (-10..190 C)
     * Scale: 0.04884
     * Offset: -10
     */
    int16_t t2s7;

    /**
     * Range: 0..4095.004095004095004095004095 (-10..190 C)
     * Scale: 0.04884
     * Offset: -10
     */
    int16_t t2s8;

    /**
     * Range: 0..4095.004095004095004095004095 (-10..190 C)
     * Scale: 0.04884
     * Offset: -10
     */
    int16_t t2s9;

    /**
     * Range: 0..4095.004095004095004095004095 (-10..190 C)
     * Scale: 0.04884
     * Offset: -10
     */
    int16_t t2s10;

    /**
     * Range: 0..4095.004095004095004095004095 (-10..190 C)
     * Scale: 0.04884
     * Offset: -10
     */
    int16_t t2s11;

    /**
     * Range: 0..4095.004095004095004095004095 (-10..190 C)
     * Scale: 0.04884
     * Offset: -10
     */
    int16_t t2s12;

    /**
     * Range: 0..4095.004095004095004095004095 (-10..190 C)
     * Scale: 0.04884
     * Offset: -10
     */
    int16_t t3s1;

    /**
     * Range: 0..4095.004095004095004095004095 (-10..190 C)
     * Scale: 0.04884
     * Offset: -10
     */
    int16_t t3s2;

    /**
     * Range: 0..4095.004095004095004095004095 (-10..190 C)
     * Scale: 0.04884
     * Offset: -10
     */
    int16_t t3s3;

    /**
     * Range: 0..4095.004095004095004095004095 (-10..190 C)
     * Scale: 0.04884
     * Offset: -10
     */
    int16_t t3s4;

    /**
     * Range: 0..4095.004095004095004095004095 (-10..190 C)
     * Scale: 0.04884
     * Offset: -10
     */
    int16_t t3s5;

    /**
     * Range: 0..4095.004095004095004095004095 (-10..190 C)
     * Scale: 0.04884
     * Offset: -10
     */
    int16_t t3s6;

    /**
     * Range: 0..4095.004095004095004095004095 (-10..190 C)
     * Scale: 0.04884
     * Offset: -10
     */
    int16_t t3s7;

    /**
     * Range: 0..4095.004095004095004095004095 (-10..190 C)
     * Scale: 0.04884
     * Offset: -10
     */
    int16_t t3s8;

    /**
     * Range: 0..4095.004095004095004095004095 (-10..190 C)
     * Scale: 0.04884
     * Offset: -10
     */
    int16_t t3s9;

    /**
     * Range: 0..4095.004095004095004095004095 (-10..190 C)
     * Scale: 0.04884
     * Offset: -10
     */
    int16_t t3s10;

    /**
     * Range: 0..4095.004095004095004095004095 (-10..190 C)
     * Scale: 0.04884
     * Offset: -10
     */
    int16_t t3s11;

    /**
     * Range: 0..4095.004095004095004095004095 (-10..190 C)
     * Scale: 0.04884
     * Offset: -10
     */
    int16_t t3s12;

    /**
     * Range: 0..4095.004095004095004095004095 (-10..190 C)
     * Scale: 0.04884
     * Offset: -10
     */
    int16_t t4s1;

    /**
     * Range: 0..4095.004095004095004095004095 (-10..190 C)
     * Scale: 0.04884
     * Offset: -10
     */
    int16_t t4s2;

    /**
     * Range: 0..4095.004095004095004095004095 (-10..190 C)
     * Scale: 0.04884
     * Offset: -10
     */
    int16_t t4s3;

    /**
     * Range: 0..4095.004095004095004095004095 (-10..190 C)
     * Scale: 0.04884
     * Offset: -10
     */
    int16_t t4s4;

    /**
     * Range: 0..4095.004095004095004095004095 (-10..190 C)
     * Scale: 0.04884
     * Offset: -10
     */
    int16_t t4s5;

    /**
     * Range: 0..4095.004095004095004095004095 (-10..190 C)
     * Scale: 0.04884
     * Offset: -10
     */
    int16_t t4s6;

    /**
     * Range: 0..4095.004095004095004095004095 (-10..190 C)
     * Scale: 0.04884
     * Offset: -10
     */
    int16_t t4s7;

    /**
     * Range: 0..4095.004095004095004095004095 (-10..190 C)
     * Scale: 0.04884
     * Offset: -10
     */
    int16_t t4s8;

    /**
     * Range: 0..4095.004095004095004095004095 (-10..190 C)
     * Scale: 0.04884
     * Offset: -10
     */
    int16_t t4s9;

    /**
     * Range: 0..4095.004095004095004095004095 (-10..190 C)
     * Scale: 0.04884
     * Offset: -10
     */
    int16_t t4s10;

    /**
     * Range: 0..4095.004095004095004095004095 (-10..190 C)
     * Scale: 0.04884
     * Offset: -10
     */
    int16_t t4s11;

    /**
     * Range: 0..4095.004095004095004095004095 (-10..190 C)
     * Scale: 0.04884
     * Offset: -10
     */
    int16_t t4s12;

    /**
     * Range: 0..4095.004095004095004095004095 (-10..190 C)
     * Scale: 0.04884
     * Offset: -10
     */
    int16_t t5s1;

    /**
     * Range: 0..4095.004095004095004095004095 (-10..190 C)
     * Scale: 0.04884
     * Offset: -10
     */
    int16_t t5s2;

    /**
     * Range: 0..4095.004095004095004095004095 (-10..190 C)
     * Scale: 0.04884
     * Offset: -10
     */
    int16_t t5s3;

    /**
     * Range: 0..4095.004095004095004095004095 (-10..190 C)
     * Scale: 0.04884
     * Offset: -10
     */
    int16_t t5s4;

    /**
     * Range: 0..4095.004095004095004095004095 (-10..190 C)
     * Scale: 0.04884
     * Offset: -10
     */
    int16_t t5s5;

    /**
     * Range: 0..4095.004095004095004095004095 (-10..190 C)
     * Scale: 0.04884
     * Offset: -10
     */
    int16_t t5s6;

    /**
     * Range: 0..4095.004095004095004095004095 (-10..190 C)
     * Scale: 0.04884
     * Offset: -10
     */
    int16_t t5s7;

    /**
     * Range: 0..4095.004095004095004095004095 (-10..190 C)
     * Scale: 0.04884
     * Offset: -10
     */
    int16_t t5s8;

    /**
     * Range: 0..4095.004095004095004095004095 (-10..190 C)
     * Scale: 0.04884
     * Offset: -10
     */
    int16_t t5s9;

    /**
     * Range: 0..4095.004095004095004095004095 (-10..190 C)
     * Scale: 0.04884
     * Offset: -10
     */
    int16_t t5s10;

    /**
     * Range: 0..4095.004095004095004095004095 (-10..190 C)
     * Scale: 0.04884
     * Offset: -10
     */
    int16_t t5s11;

    /**
     * Range: 0..4095.004095004095004095004095 (-10..190 C)
     * Scale: 0.04884
     * Offset: -10
     */
    int16_t t5s12;
};

/**
 * Signals in message ecu_status.
 *
 * All signal values are as on the CAN bus.
 */
struct can1_ecu_status_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t ts_not_off;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t rst_button;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t close_airs;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t ts_off;
};

/**
 * Signals in message ebs_status.
 *
 * All signal values are as on the CAN bus.
 */
struct can1_ebs_status_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t sc_tsms_status;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t res_open;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t ebs_status;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t ebs_state_machine;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint16_t ebs_pressure_1;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint16_t ebs_pressure_2;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t ebs_error;
};

/**
 * Signals in message dcu_pps.
 *
 * All signal values are as on the CAN bus.
 */
struct can1_dcu_pps_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint16_t apps_1;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint16_t apps_2;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint16_t bpps_1;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint16_t bpps_2;

    /**
     * Range: 0..51.2 (0..51.2 deg)
     * Scale: 1
     * Offset: 0
     */
    uint16_t acceleration_pedal_angle;

    /**
     * Range: 0..1.28 (0..12.8 deg)
     * Scale: 10
     * Offset: 0
     */
    uint8_t brake_pedal_angle;
};

/**
 * Signals in message dcu_status.
 *
 * All signal values are as on the CAN bus.
 */
struct can1_dcu_status_t {
    /**
     * Range: 0..65535.00814600151254798800971 (0..1 .)
     * Scale: 1.525902e-05
     * Offset: 0
     */
    uint16_t normalized_brake_pedal_travel;

    /**
     * Range: 0..65535.00814600151254798800971 (0..1 .)
     * Scale: 1.525902e-05
     * Offset: 0
     */
    uint16_t normalized_accelerator_pedal_travel;

    /**
     * Range: -10000..10000 (-100..100 degrees)
     * Scale: 0.01
     * Offset: 0
     */
    int16_t normalized_steering_wheel_angle;
};

/**
 * Signals in message mcu_set_ccu_cooling_points.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
struct can1_mcu_set_ccu_cooling_points_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t mux_id;

    /**
     * Range: 0..100 (0..100 %)
     * Scale: 1
     * Offset: 0
     */
    uint8_t fan1_speed;

    /**
     * Range: 0..100 (0..100 %)
     * Scale: 1
     * Offset: 0
     */
    uint8_t fan2_speed;

    /**
     * Range: 0..100 (0..100 %)
     * Scale: 1
     * Offset: 0
     */
    uint8_t fan3_speed;

    /**
     * Range: 0..100 (0..100 %)
     * Scale: 1
     * Offset: 0
     */
    uint8_t fron_pump_speed;

    /**
     * Range: 0..100 (0..100 %)
     * Scale: 1
     * Offset: 0
     */
    uint8_t rear_pump_speed;

    /**
     * Range: 0..100 (0..100 %)
     * Scale: 1
     * Offset: 0
     */
    uint8_t inverter_pump_speed;
};

/**
 * Signals in message ccu_status_1.
 *
 * All signal values are as on the CAN bus.
 */
struct can1_ccu_status_1_t {
    /**
     * Range: 0..2 (0..2 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t mux_id;

    /**
     * Range: 0..100 (0..100 %)
     * Scale: 1
     * Offset: 0
     */
    uint8_t fan1_temperature;

    /**
     * Range: 0..100 (0..100 %)
     * Scale: 1
     * Offset: 0
     */
    uint8_t fan2_temperature;

    /**
     * Range: 0..100 (0..100 %)
     * Scale: 1
     * Offset: 0
     */
    uint8_t fan3_temperature;

    /**
     * Range: 0..100 (0..100 %)
     * Scale: 1
     * Offset: 0
     */
    uint8_t fron_pump_temperature;

    /**
     * Range: 0..100 (0..100 %)
     * Scale: 1
     * Offset: 0
     */
    uint8_t rear_pump_temperature;

    /**
     * Range: 0..100 (0..100 %)
     * Scale: 1
     * Offset: 0
     */
    uint8_t inverter_pump_temperature;
};

/**
 * Signals in message ccu_status_2.
 *
 * All signal values are as on the CAN bus.
 */
struct can1_ccu_status_2_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t digital_input;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t discharge_relay_open;

    /**
     * Range: 4294967296..200 (4294967286..190 C)
     * Scale: 1
     * Offset: -10
     */
    uint16_t discharge_resistor_temperature;

    /**
     * Range: 4294967296..200 (4294967286..190 C)
     * Scale: 1
     * Offset: -10
     */
    uint16_t extra_temperature;
};

/**
 * Signals in message vehicle_status.
 *
 * All signal values are as on the CAN bus.
 */
struct can1_vehicle_status_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t car_state;

    /**
     * Range: 0..200 (0..200 kph)
     * Scale: 1
     * Offset: 0
     */
    uint8_t car_velocity;

    /**
     * Range: 0..100 (0..100 kW)
     * Scale: 1
     * Offset: 0
     */
    uint16_t car_power;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t car_regen_level;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t ready_to_drive;
};

/**
 * Signals in message fault.
 *
 * All signal values are as on the CAN bus.
 */
struct can1_fault_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t unit_id;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t apps_discrepancy;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t sc_open;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t ts_off_watchdog_triggered;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t bpps_discrepancy;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t brake_pressure_discrepancy;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t steering_angle_discrepancy;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t apps_out_of_range;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t bpps_out_of_range;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t brake_pressure_out_of_range;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t steering_angle_out_of_range;
};

/**
 * Signals in message dcu_status_steering_brake.
 *
 * All signal values are as on the CAN bus.
 */
struct can1_dcu_status_steering_brake_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t bspd_triggered;

    /**
     * Range: 0..190 (0..190 C)
     * Scale: 1
     * Offset: 0
     */
    uint16_t dcu_temperature;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    int16_t steering_angle_1;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    int16_t steering_angle_2;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint16_t brake_pressure_1;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint16_t brake_pressure_2;
};

/**
 * Signals in message dbu_status_2.
 *
 * Used for DBU software IO.
 *
 * All signal values are as on the CAN bus.
 */
struct can1_dbu_status_2_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t screen_id;
};

/**
 * Signals in message dv_control_target.
 *
 * All signal values are as on the CAN bus.
 */
struct can1_dv_control_target_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint16_t dv_speed_target;

    /**
     * Range: -
     * Scale: 0.25
     * Offset: 0
     */
    int16_t dv_steering_angle_target;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t dv_brake_hydralic_target;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    int16_t dv_motor_moment_target;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t dv_mission_status;
};

/**
 * Signals in message vehicle_status_wheel_speed.
 *
 * All signal values are as on the CAN bus.
 */
struct can1_vehicle_status_wheel_speed_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    int16_t wheel_speed_fl;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    int16_t wheel_speed_fr;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    int16_t wheel_speed_rl;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    int16_t wheel_speed_rr;
};

/**
 * Signals in message SBG_ECAN_MSG_GPS2_HDT.
 *
 * All signal values are as on the CAN bus.
 */
struct can1_sbg_ecan_msg_gps2_hdt_t {
    /**
     * Range: 0..65535 (0..655.35 )
     * Scale: 0.01
     * Offset: 0
     */
    uint16_t true_heading;

    /**
     * Range: 0..65535 (0..655.35 )
     * Scale: 0.01
     * Offset: 0
     */
    uint16_t true_heading_acc;

    /**
     * Range: -32768..32767 (-327.68..327.67 )
     * Scale: 0.01
     * Offset: 0
     */
    int16_t pitch;

    /**
     * Range: 0..65535 (0..655.35 )
     * Scale: 0.01
     * Offset: 0
     */
    uint16_t pitch_acc;
};

/**
 * Signals in message SBG_ECAN_MSG_GPS2_HDT_INFO.
 *
 * All signal values are as on the CAN bus.
 */
struct can1_sbg_ecan_msg_gps2_hdt_info_t {
    /**
     * Range: 0..2704 (0..2704 s)
     * Scale: 1
     * Offset: 0
     */
    uint32_t time_stamp;

    /**
     * Range: 0..65535 (0..65535 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t status;
};

/**
 * Signals in message SBG_ECAN_MSG_GPS2_POS_ACC.
 *
 * All signal values are as on the CAN bus.
 */
struct can1_sbg_ecan_msg_gps2_pos_acc_t {
    /**
     * Range: 0..65535 (0..655.35 m)
     * Scale: 0.01
     * Offset: 0
     */
    uint16_t latitude_acc;

    /**
     * Range: 0..65535 (0..655.35 m)
     * Scale: 0.01
     * Offset: 0
     */
    uint16_t longitude_acc;

    /**
     * Range: 0..65535 (0..655.35 m)
     * Scale: 0.01
     * Offset: 0
     */
    uint16_t altitude_acc;

    /**
     * Range: 0..65535 (0..65535 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t base_station_id;
};

/**
 * Signals in message SBG_ECAN_MSG_GPS2_POS_ALT.
 *
 * All signal values are as on the CAN bus.
 */
struct can1_sbg_ecan_msg_gps2_pos_alt_t {
    /**
     * Range: -2147480000..2147480000 (-2147480..2147480 m)
     * Scale: 0.001
     * Offset: 0
     */
    int32_t altitude;

    /**
     * Range: -32768..32767 (-163.84..163.835 m)
     * Scale: 0.005
     * Offset: 0
     */
    int16_t undulation;

    /**
     * Range: 0..255 (48..303 -)
     * Scale: 1
     * Offset: 48
     */
    uint8_t num_sv;

    /**
     * Range: 0..255 (7..262 s)
     * Scale: 1
     * Offset: 7
     */
    uint8_t diff_corr_age;
};

/**
 * Signals in message SBG_ECAN_MSG_GPS2_POS.
 *
 * All signal values are as on the CAN bus.
 */
struct can1_sbg_ecan_msg_gps2_pos_t {
    /**
     * Range: -21474800000..21474800000 (-2147.48..2147.48 )
     * Scale: 1e-07
     * Offset: 0
     */
    int32_t latitude;

    /**
     * Range: -21474800000..21474800000 (-2147.48..2147.48 )
     * Scale: 1e-07
     * Offset: 0
     */
    int32_t longitude;
};

/**
 * Signals in message SBG_ECAN_MSG_GPS2_POS_INFO.
 *
 * All signal values are as on the CAN bus.
 */
struct can1_sbg_ecan_msg_gps2_pos_info_t {
    /**
     * Range: 0..2704 (0..2704 s)
     * Scale: 1
     * Offset: 0
     */
    uint32_t time_stamp;

    /**
     * Range: 0..2704 (0..2704 -)
     * Scale: 1
     * Offset: 0
     */
    uint32_t status;
};

/**
 * Signals in message SBG_ECAN_MSG_GPS2_VEL_COURSE.
 *
 * All signal values are as on the CAN bus.
 */
struct can1_sbg_ecan_msg_gps2_vel_course_t {
    /**
     * Range: 0..65535 (0..655.35 )
     * Scale: 0.01
     * Offset: 0
     */
    uint16_t course;

    /**
     * Range: 0..65535 (0..655.35 )
     * Scale: 0.01
     * Offset: 0
     */
    uint16_t course_acc;
};

/**
 * Signals in message SBG_ECAN_MSG_GPS2_VEL_ACC.
 *
 * All signal values are as on the CAN bus.
 */
struct can1_sbg_ecan_msg_gps2_vel_acc_t {
    /**
     * Range: -32768..32767 (-327.68..327.67 m.s-1)
     * Scale: 0.01
     * Offset: 0
     */
    int16_t velocity_acc_n;

    /**
     * Range: -32768..32767 (-327.68..327.67 m.s-1)
     * Scale: 0.01
     * Offset: 0
     */
    int16_t velocity_acc_e;

    /**
     * Range: -32768..32767 (-327.68..327.67 m.s-1)
     * Scale: 0.01
     * Offset: 0
     */
    int16_t velocity_acc_d;
};

/**
 * Signals in message SBG_ECAN_MSG_GPS2_VEL.
 *
 * All signal values are as on the CAN bus.
 */
struct can1_sbg_ecan_msg_gps2_vel_t {
    /**
     * Range: -32768..32767 (-327.68..327.67 m.s-1)
     * Scale: 0.01
     * Offset: 0
     */
    int16_t velocity_n;

    /**
     * Range: -32768..32767 (-327.68..327.67 m.s-1)
     * Scale: 0.01
     * Offset: 0
     */
    int16_t velocity_e;

    /**
     * Range: -32768..32767 (-327.68..327.67 m.s-1)
     * Scale: 0.01
     * Offset: 0
     */
    int16_t velocity_d;
};

/**
 * Signals in message SBG_ECAN_MSG_GPS2_VEL_INFO.
 *
 * All signal values are as on the CAN bus.
 */
struct can1_sbg_ecan_msg_gps2_vel_info_t {
    /**
     * Range: 0..2704 (0..2704 s)
     * Scale: 1
     * Offset: 0
     */
    uint32_t time_stamp;

    /**
     * Range: 0..2704 (0..2704 -)
     * Scale: 1
     * Offset: 0
     */
    uint32_t status;
};

/**
 * Signals in message SBG_ECAN_MSG_GPS1_HDT.
 *
 * All signal values are as on the CAN bus.
 */
struct can1_sbg_ecan_msg_gps1_hdt_t {
    /**
     * Range: 0..65535 (0..655.35 )
     * Scale: 0.01
     * Offset: 0
     */
    uint16_t true_heading;

    /**
     * Range: 0..65535 (0..655.35 )
     * Scale: 0.01
     * Offset: 0
     */
    uint16_t true_heading_acc;

    /**
     * Range: -32768..32767 (-327.68..327.67 )
     * Scale: 0.01
     * Offset: 0
     */
    int16_t pitch;

    /**
     * Range: 0..65535 (0..655.35 )
     * Scale: 0.01
     * Offset: 0
     */
    uint16_t pitch_acc;
};

/**
 * Signals in message SBG_ECAN_MSG_GPS1_HDT_INFO.
 *
 * All signal values are as on the CAN bus.
 */
struct can1_sbg_ecan_msg_gps1_hdt_info_t {
    /**
     * Range: 0..2704 (0..2704 s)
     * Scale: 1
     * Offset: 0
     */
    uint32_t time_stamp;

    /**
     * Range: 0..65535 (0..65535 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t status;
};

/**
 * Signals in message SBG_ECAN_MSG_GPS1_POS_ACC.
 *
 * All signal values are as on the CAN bus.
 */
struct can1_sbg_ecan_msg_gps1_pos_acc_t {
    /**
     * Range: 0..65535 (0..655.35 m)
     * Scale: 0.01
     * Offset: 0
     */
    uint16_t latitude_acc;

    /**
     * Range: 0..65535 (0..655.35 m)
     * Scale: 0.01
     * Offset: 0
     */
    uint16_t longitude_acc;

    /**
     * Range: 0..65535 (0..655.35 m)
     * Scale: 0.01
     * Offset: 0
     */
    uint16_t altitude_acc;

    /**
     * Range: 0..65535 (0..65535 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t base_station_id;
};

/**
 * Signals in message SBG_ECAN_MSG_GPS1_POS_ALT.
 *
 * All signal values are as on the CAN bus.
 */
struct can1_sbg_ecan_msg_gps1_pos_alt_t {
    /**
     * Range: -2147480000..2147480000 (-2147480..2147480 m)
     * Scale: 0.001
     * Offset: 0
     */
    int32_t altitude;

    /**
     * Range: -32768..32767 (-163.84..163.835 m)
     * Scale: 0.005
     * Offset: 0
     */
    int16_t undulation;

    /**
     * Range: 0..255 (48..303 -)
     * Scale: 1
     * Offset: 48
     */
    uint8_t num_sv;

    /**
     * Range: 0..255 (7..262 s)
     * Scale: 1
     * Offset: 7
     */
    uint8_t diff_corr_age;
};

/**
 * Signals in message SBG_ECAN_MSG_GPS1_POS.
 *
 * All signal values are as on the CAN bus.
 */
struct can1_sbg_ecan_msg_gps1_pos_t {
    /**
     * Range: -21474800000..21474800000 (-2147.48..2147.48 )
     * Scale: 1e-07
     * Offset: 0
     */
    int32_t latitude;

    /**
     * Range: -21474800000..21474800000 (-2147.48..2147.48 )
     * Scale: 1e-07
     * Offset: 0
     */
    int32_t longitude;
};

/**
 * Signals in message SBG_ECAN_MSG_GPS1_POS_INFO.
 *
 * All signal values are as on the CAN bus.
 */
struct can1_sbg_ecan_msg_gps1_pos_info_t {
    /**
     * Range: 0..2704 (0..2704 s)
     * Scale: 1
     * Offset: 0
     */
    uint32_t time_stamp;

    /**
     * Range: 0..2704 (0..2704 -)
     * Scale: 1
     * Offset: 0
     */
    uint32_t status;
};

/**
 * Signals in message SBG_ECAN_MSG_GPS1_VEL_COURSE.
 *
 * All signal values are as on the CAN bus.
 */
struct can1_sbg_ecan_msg_gps1_vel_course_t {
    /**
     * Range: 0..65535 (0..655.35 )
     * Scale: 0.01
     * Offset: 0
     */
    uint16_t course;

    /**
     * Range: 0..65535 (0..655.35 )
     * Scale: 0.01
     * Offset: 0
     */
    uint16_t course_acc;
};

/**
 * Signals in message SBG_ECAN_MSG_GPS1_VEL_ACC.
 *
 * All signal values are as on the CAN bus.
 */
struct can1_sbg_ecan_msg_gps1_vel_acc_t {
    /**
     * Range: -32768..32767 (-327.68..327.67 m.s-1)
     * Scale: 0.01
     * Offset: 0
     */
    int16_t velocity_acc_n;

    /**
     * Range: -32768..32767 (-327.68..327.67 m.s-1)
     * Scale: 0.01
     * Offset: 0
     */
    int16_t velocity_acc_e;

    /**
     * Range: -32768..32767 (-327.68..327.67 m.s-1)
     * Scale: 0.01
     * Offset: 0
     */
    int16_t velocity_acc_d;
};

/**
 * Signals in message SBG_ECAN_MSG_GPS1_VEL.
 *
 * All signal values are as on the CAN bus.
 */
struct can1_sbg_ecan_msg_gps1_vel_t {
    /**
     * Range: -32768..32767 (-327.68..327.67 m.s-1)
     * Scale: 0.01
     * Offset: 0
     */
    int16_t velocity_n;

    /**
     * Range: -32768..32767 (-327.68..327.67 m.s-1)
     * Scale: 0.01
     * Offset: 0
     */
    int16_t velocity_e;

    /**
     * Range: -32768..32767 (-327.68..327.67 m.s-1)
     * Scale: 0.01
     * Offset: 0
     */
    int16_t velocity_d;
};

/**
 * Signals in message SBG_ECAN_MSG_GPS1_VEL_INFO.
 *
 * All signal values are as on the CAN bus.
 */
struct can1_sbg_ecan_msg_gps1_vel_info_t {
    /**
     * Range: 0..2704 (0..2704 s)
     * Scale: 1
     * Offset: 0
     */
    uint32_t time_stamp;

    /**
     * Range: 0..2704 (0..2704 -)
     * Scale: 1
     * Offset: 0
     */
    uint32_t status;
};

/**
 * Signals in message SBG_ECAN_MSG_ODO_VEL.
 *
 * All signal values are as on the CAN bus.
 */
struct can1_sbg_ecan_msg_odo_vel_t {
    /**
     * Range: -32768..32767 (-327.68..327.67 m.s-1)
     * Scale: 0.01
     * Offset: 0
     */
    int16_t velocity;
};

/**
 * Signals in message SBG_ECAN_MSG_ODO_INFO.
 *
 * All signal values are as on the CAN bus.
 */
struct can1_sbg_ecan_msg_odo_info_t {
    /**
     * Range: 0..2704 (0..2704 s)
     * Scale: 1
     * Offset: 0
     */
    uint32_t time_stamp;

    /**
     * Range: 0..65535 (0..65535 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t odo_status;
};

/**
 * Signals in message SBG_ECAN_MSG_EKF_VEL_BODY.
 *
 * All signal values are as on the CAN bus.
 */
struct can1_sbg_ecan_msg_ekf_vel_body_t {
    /**
     * Range: -32768..32767 (-327.68..327.67 m.s-1)
     * Scale: 0.01
     * Offset: 0
     */
    int16_t velocity_x;

    /**
     * Range: -32768..32767 (-327.68..327.67 m.s-1)
     * Scale: 0.01
     * Offset: 0
     */
    int16_t velocity_y;

    /**
     * Range: -32768..32767 (-327.68..327.67 m.s-1)
     * Scale: 0.01
     * Offset: 0
     */
    int16_t velocity_z;
};

/**
 * Signals in message SBG_ECAN_MSG_EKF_VEL_NED_ACC.
 *
 * All signal values are as on the CAN bus.
 */
struct can1_sbg_ecan_msg_ekf_vel_ned_acc_t {
    /**
     * Range: -32768..32767 (-327.68..327.67 m.s-1)
     * Scale: 0.01
     * Offset: 0
     */
    int16_t velocity_acc_n;

    /**
     * Range: -32768..32767 (-327.68..327.67 m.s-1)
     * Scale: 0.01
     * Offset: 0
     */
    int16_t velocity_acc_e;

    /**
     * Range: -32768..32767 (-327.68..327.67 m.s-1)
     * Scale: 0.01
     * Offset: 0
     */
    int16_t velocity_acc_d;
};

/**
 * Signals in message SBG_ECAN_MSG_EKF_VEL_NED.
 *
 * All signal values are as on the CAN bus.
 */
struct can1_sbg_ecan_msg_ekf_vel_ned_t {
    /**
     * Range: -32768..32767 (-327.68..327.67 m.s-1)
     * Scale: 0.01
     * Offset: 0
     */
    int16_t velocity_n;

    /**
     * Range: -32768..32767 (-327.68..327.67 m.s-1)
     * Scale: 0.01
     * Offset: 0
     */
    int16_t velocity_e;

    /**
     * Range: -32768..32767 (-327.68..327.67 m.s-1)
     * Scale: 0.01
     * Offset: 0
     */
    int16_t velocity_d;
};

/**
 * Signals in message SBG_ECAN_MSG_EKF_POS_ACC.
 *
 * All signal values are as on the CAN bus.
 */
struct can1_sbg_ecan_msg_ekf_pos_acc_t {
    /**
     * Range: 0..65535 (0..655.35 m)
     * Scale: 0.01
     * Offset: 0
     */
    uint16_t latitude_acc;

    /**
     * Range: 0..65535 (0..655.35 m)
     * Scale: 0.01
     * Offset: 0
     */
    uint16_t longitude_acc;

    /**
     * Range: 0..65535 (0..655.35 m)
     * Scale: 0.01
     * Offset: 0
     */
    uint16_t altitude_acc;
};

/**
 * Signals in message SBG_ECAN_MSG_EKF_POS.
 *
 * All signal values are as on the CAN bus.
 */
struct can1_sbg_ecan_msg_ekf_pos_t {
    /**
     * Range: -21474800000..21474800000 (-2147.48..2147.48 )
     * Scale: 1e-07
     * Offset: 0
     */
    int32_t latitude;

    /**
     * Range: -21474800000..21474800000 (-2147.48..2147.48 )
     * Scale: 1e-07
     * Offset: 0
     */
    int32_t longitude;
};

/**
 * Signals in message SBG_ECAN_MSG_EKF_ORIENTATION_ACC.
 *
 * All signal values are as on the CAN bus.
 */
struct can1_sbg_ecan_msg_ekf_orientation_acc_t {
    /**
     * Range: 0..65535 (0..6.5535 rad)
     * Scale: 0.0001
     * Offset: 0
     */
    uint16_t roll_acc;

    /**
     * Range: 0..65535 (0..6.5535 rad)
     * Scale: 0.0001
     * Offset: 0
     */
    uint16_t pitch_acc;

    /**
     * Range: 0..65535 (0..6.5535 rad)
     * Scale: 0.0001
     * Offset: 0
     */
    uint16_t yaw_acc;
};

/**
 * Signals in message SBG_ECAN_MSG_EKF_EULER.
 *
 * All signal values are as on the CAN bus.
 */
struct can1_sbg_ecan_msg_ekf_euler_t {
    /**
     * Range: -32768..32767 (-3.2768..3.2767 rad)
     * Scale: 0.0001
     * Offset: 0
     */
    int16_t roll;

    /**
     * Range: -32768..32767 (-3.2768..3.2767 rad)
     * Scale: 0.0001
     * Offset: 0
     */
    int16_t pitch;

    /**
     * Range: -32768..32767 (-3.2768..3.2767 rad)
     * Scale: 0.0001
     * Offset: 0
     */
    int16_t yaw;
};

/**
 * Signals in message SBG_ECAN_MSG_EKF_QUAT.
 *
 * All signal values are as on the CAN bus.
 */
struct can1_sbg_ecan_msg_ekf_quat_t {
    /**
     * Range: -33286.06208..33285.07904 (-1.01581..1.01578 -)
     * Scale: 3.0517578125e-05
     * Offset: 0
     */
    int16_t q0;

    /**
     * Range: -33286.06208..33285.07904 (-1.01581..1.01578 -)
     * Scale: 3.0517578125e-05
     * Offset: 0
     */
    int16_t q1;

    /**
     * Range: -33286.06208..33285.07904 (-1.01581..1.01578 -)
     * Scale: 3.0517578125e-05
     * Offset: 0
     */
    int16_t q2;

    /**
     * Range: -33286.06208..33285.07904 (-1.01581..1.01578 -)
     * Scale: 3.0517578125e-05
     * Offset: 0
     */
    int16_t q3;
};

/**
 * Signals in message SBG_ECAN_MSG_EKF_INFO.
 *
 * All signal values are as on the CAN bus.
 */
struct can1_sbg_ecan_msg_ekf_info_t {
    /**
     * Range: 0..2704 (0..2704 s)
     * Scale: 1
     * Offset: 0
     */
    uint32_t time_stamp;
};

/**
 * Signals in message SBG_ECAN_MSG_IMU_DELTA_ANGLE.
 *
 * All signal values are as on the CAN bus.
 */
struct can1_sbg_ecan_msg_imu_delta_angle_t {
    /**
     * Range: -32768..32767 (-32.768..32.767 rad.s-1)
     * Scale: 0.001
     * Offset: 0
     */
    int16_t delta_angle_x;

    /**
     * Range: -32768..32767 (-32.768..32.767 rad.s-1)
     * Scale: 0.001
     * Offset: 0
     */
    int16_t delta_angle_y;

    /**
     * Range: -32768..32767 (-32.768..32.767 rad.s-1)
     * Scale: 0.001
     * Offset: 0
     */
    int16_t delta_angle_z;
};

/**
 * Signals in message SBG_ECAN_MSG_IMU_DELTA_VEL.
 *
 * All signal values are as on the CAN bus.
 */
struct can1_sbg_ecan_msg_imu_delta_vel_t {
    /**
     * Range: -32768..32767 (-327.68..327.67 m.s-2)
     * Scale: 0.01
     * Offset: 0
     */
    int16_t delta_vel_x;

    /**
     * Range: -32768..32767 (-327.68..327.67 m.s-2)
     * Scale: 0.01
     * Offset: 0
     */
    int16_t delta_vel_y;

    /**
     * Range: -32768..32767 (-327.68..327.67 m.s-2)
     * Scale: 0.01
     * Offset: 0
     */
    int16_t delta_vel_z;
};

/**
 * Signals in message SBG_ECAN_MSG_IMU_GYRO.
 *
 * All signal values are as on the CAN bus.
 */
struct can1_sbg_ecan_msg_imu_gyro_t {
    /**
     * Range: -32768..32767 (-32.768..32.767 rad.s-1)
     * Scale: 0.001
     * Offset: 0
     */
    int16_t gyro_x;

    /**
     * Range: -32768..32767 (-32.768..32.767 rad.s-1)
     * Scale: 0.001
     * Offset: 0
     */
    int16_t gyro_y;

    /**
     * Range: -32768..32767 (-32.768..32.767 rad.s-1)
     * Scale: 0.001
     * Offset: 0
     */
    int16_t gyro_z;
};

/**
 * Signals in message SBG_ECAN_MSG_IMU_ACCEL.
 *
 * All signal values are as on the CAN bus.
 */
struct can1_sbg_ecan_msg_imu_accel_t {
    /**
     * Range: -32768..32767 (-327.68..327.67 m.s-2)
     * Scale: 0.01
     * Offset: 0
     */
    int16_t accel_x;

    /**
     * Range: -32768..32767 (-327.68..327.67 m.s-2)
     * Scale: 0.01
     * Offset: 0
     */
    int16_t accel_y;

    /**
     * Range: -32768..32767 (-327.68..327.67 m.s-2)
     * Scale: 0.01
     * Offset: 0
     */
    int16_t accel_z;
};

/**
 * Signals in message SBG_ECAN_MSG_IMU_INFO.
 *
 * All signal values are as on the CAN bus.
 */
struct can1_sbg_ecan_msg_imu_info_t {
    /**
     * Range: 0..2704 (0..2704 s)
     * Scale: 1
     * Offset: 0
     */
    uint32_t time_stamp;

    /**
     * Range: 0..65535 (0..65535 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t status;

    /**
     * Range: -32768..32767 (-327.68..327.67 C)
     * Scale: 0.01
     * Offset: 0
     */
    int16_t temperature;
};

/**
 * Signals in message SBG_ECAN_MSG_UTC_1.
 *
 * All signal values are as on the CAN bus.
 */
struct can1_sbg_ecan_msg_utc_1_t {
    /**
     * Range: 0..255 (2000..2255 year)
     * Scale: 1
     * Offset: 2000
     */
    uint8_t year;

    /**
     * Range: 0..255 (0..255 month)
     * Scale: 1
     * Offset: 0
     */
    uint8_t month;

    /**
     * Range: 0..255 (0..255 d)
     * Scale: 1
     * Offset: 0
     */
    uint8_t day;

    /**
     * Range: 0..255 (0..255 h)
     * Scale: 1
     * Offset: 0
     */
    uint8_t hour;

    /**
     * Range: 0..255 (0..255 min)
     * Scale: 1
     * Offset: 0
     */
    uint8_t min;

    /**
     * Range: 0..255 (0..255 s)
     * Scale: 1
     * Offset: 0
     */
    uint8_t sec;

    /**
     * Range: 0..65535 (0..6553500 us)
     * Scale: 100
     * Offset: 0
     */
    uint16_t micro_sec;
};

/**
 * Signals in message SBG_ECAN_MSG_UTC_0.
 *
 * All signal values are as on the CAN bus.
 */
struct can1_sbg_ecan_msg_utc_0_t {
    /**
     * Range: 0..2704 (0..2704 s)
     * Scale: 1
     * Offset: 0
     */
    uint32_t time_stamp;

    /**
     * Range: 0..2704 (0..2704 ms)
     * Scale: 1
     * Offset: 0
     */
    uint32_t gps_tow;
};

/**
 * Signals in message FS_Datalogger_Reserved_6.
 *
 * Specified by FSG document, not sure of the purpose. 
 *
 * All signal values are as on the CAN bus.
 */
struct can1_fs_datalogger_reserved_6_t {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;
};

/**
 * Signals in message FS_Datalogger_Reserved_5.
 *
 * Specified by FSG document, not sure of the purpose. 
 *
 * All signal values are as on the CAN bus.
 */
struct can1_fs_datalogger_reserved_5_t {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;
};

/**
 * Signals in message FS_Datalogger_Reserved_4.
 *
 * Specified by FSG document, not sure of the purpose. 
 *
 * All signal values are as on the CAN bus.
 */
struct can1_fs_datalogger_reserved_4_t {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;
};

/**
 * Signals in message FS_Datalogger_Reserved_3.
 *
 * Specified by FSG document, not sure of the purpose. 
 *
 * All signal values are as on the CAN bus.
 */
struct can1_fs_datalogger_reserved_3_t {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;
};

/**
 * Signals in message FS_Datalogger_Reserved_2.
 *
 * Specified by FSG document, not sure of the purpose. 
 *
 * All signal values are as on the CAN bus.
 */
struct can1_fs_datalogger_reserved_2_t {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;
};

/**
 * Signals in message FS_Datalogger_Reserved_1.
 *
 * Specified by FSG document, not sure of the purpose. 
 *
 * All signal values are as on the CAN bus.
 */
struct can1_fs_datalogger_reserved_1_t {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;
};

/**
 * Signals in message FS_Datalogger_Status.
 *
 * All signal values are as on the CAN bus.
 */
struct can1_fs_datalogger_status_t {
    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t msg_cnt;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    int8_t status_ready;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    int8_t status_logging;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    int8_t status_triggered_voltage;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    int8_t status_triggered_current;

    /**
     * Range: 0..65535 (0..1048560 mV)
     * Scale: 16
     * Offset: 0
     */
    uint16_t voltage;

    /**
     * Range: 0..65535 (0..4194240 mA)
     * Scale: 64
     * Offset: 0
     */
    uint16_t current;
};

/**
 * Signals in message vesc_status_2.
 *
 * All signal values are as on the CAN bus.
 */
struct can1_vesc_status_2_t {
    /**
     * Range: -
     * Scale: 0.0001
     * Offset: 0
     */
    int32_t amp_hours;

    /**
     * Range: -
     * Scale: 0.0001
     * Offset: 0
     */
    int32_t amp_hours_chg;
};

/**
 * Signals in message vesc_status_4.
 *
 * 
Temp Fet, Temp Motor, Current In, PID position



 *
 * All signal values are as on the CAN bus.
 */
struct can1_vesc_status_4_t {
    /**
     * Range: -
     * Scale: 0.1
     * Offset: 0
     */
    int16_t temp_fet;

    /**
     * Range: -
     * Scale: 0.1
     * Offset: 0
     */
    int16_t temp_motor;

    /**
     * Range: -
     * Scale: 0.1
     * Offset: 0
     */
    int16_t current_in;

    /**
     * Range: -
     * Scale: 0.5
     * Offset: 0
     */
    int16_t pid_pos;
};

/**
 * Signals in message vesc_status_5.
 *
 * 
Tachometer, Voltage In



 *
 * All signal values are as on the CAN bus.
 */
struct can1_vesc_status_5_t {
    /**
     * Range: -
     * Scale: 0.6
     * Offset: 0
     */
    int32_t tachometer;

    /**
     * Range: -
     * Scale: 0.1
     * Offset: 0
     */
    int16_t volts_in;
};

/**
 * Signals in message vesc_status_6.
 *
 * 
ADC1, ADC2, ADC3, PPM


 *
 * All signal values are as on the CAN bus.
 */
struct can1_vesc_status_6_t {
    /**
     * Range: -
     * Scale: 0.001
     * Offset: 0
     */
    int16_t adc1;

    /**
     * Range: -
     * Scale: 0.001
     * Offset: 0
     */
    int16_t adc2;

    /**
     * Range: -
     * Scale: 0.001
     * Offset: 0
     */
    int16_t adc3;

    /**
     * Range: -
     * Scale: 0.001
     * Offset: 0
     */
    int16_t ppm;
};

/**
 * Signals in message vesc_set_duty.
 *
 * Set duty cycle for DV motor
 *
 * All signal values are as on the CAN bus.
 */
struct can1_vesc_set_duty_t {
    /**
     * Duty Cycle
     *
     * Range: -100000..100000 (-1..1 %/100)
     * Scale: 1e-05
     * Offset: 0
     */
    int32_t set_duty;
};

/**
 * Signals in message vesc_status.
 *
 * All signal values are as on the CAN bus.
 */
struct can1_vesc_status_t {
    /**
     * ERPM
     *
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    int32_t erpm;

    /**
     * Range: -
     * Scale: 0.1
     * Offset: 0
     */
    int16_t current;

    /**
     * Range: -
     * Scale: 0.001
     * Offset: 0
     */
    int16_t duty_cycle;
};

/**
 * Signals in message ams_s1_voltages_1.
 *
 * All signal values are as on the CAN bus.
 */
struct can1_ams_s1_voltages_1_t {
    /**
     * Range: 0..255.1020408163265306122448980 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t s1v1;

    /**
     * Range: 0..255.1020408163265306122448980 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t s1v2;

    /**
     * Range: 0..255.1020408163265306122448980 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t s1v3;

    /**
     * Range: 0..255.1020408163265306122448980 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t s1v4;

    /**
     * Range: 0..255.1020408163265306122448980 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t s1v5;

    /**
     * Range: 0..255.1020408163265306122448980 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t s1v6;
};

/**
 * Signals in message ams_s1_voltages_2.
 *
 * All signal values are as on the CAN bus.
 */
struct can1_ams_s1_voltages_2_t {
    /**
     * Range: 0..255.1020408163265306122448980 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t s1v7;

    /**
     * Range: 0..255.1020408163265306122448980 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t s1v8;

    /**
     * Range: 0..255.1020408163265306122448980 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t s1v9;

    /**
     * Range: 0..255.1020408163265306122448980 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t s1v10;

    /**
     * Range: 0..255.1020408163265306122448980 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t s1v11;
};

/**
 * Signals in message ams_s2_voltages_1.
 *
 * All signal values are as on the CAN bus.
 */
struct can1_ams_s2_voltages_1_t {
    /**
     * Range: 0..255.1020408163265306122448980 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t s2v1;

    /**
     * Range: 0..255.1020408163265306122448980 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t s2v2;

    /**
     * Range: 0..255.1020408163265306122448980 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t s2v3;

    /**
     * Range: 0..255.1020408163265306122448980 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t s2v4;

    /**
     * Range: 0..255.1020408163265306122448980 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t s2v5;

    /**
     * Range: 0..255.1020408163265306122448980 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t s2v6;
};

/**
 * Signals in message ams_s2_voltages_2.
 *
 * All signal values are as on the CAN bus.
 */
struct can1_ams_s2_voltages_2_t {
    /**
     * Range: 0..255.1020408163265306122448980 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t s2v7;

    /**
     * Range: 0..255.1020408163265306122448980 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t s2v8;

    /**
     * Range: 0..255.1020408163265306122448980 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t s2v9;

    /**
     * Range: 0..255.1020408163265306122448980 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t s2v10;

    /**
     * Range: 0..255.1020408163265306122448980 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t s2v11;
};

/**
 * Signals in message ams_s3_voltages_1.
 *
 * All signal values are as on the CAN bus.
 */
struct can1_ams_s3_voltages_1_t {
    /**
     * Range: 0..255.1020408163265306122448980 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t s3v1;

    /**
     * Range: 0..255.1020408163265306122448980 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t s3v2;

    /**
     * Range: 0..255.1020408163265306122448980 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t s3v3;

    /**
     * Range: 0..255.1020408163265306122448980 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t s3v4;

    /**
     * Range: 0..255.1020408163265306122448980 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t s3v5;

    /**
     * Range: 0..255.1020408163265306122448980 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t s3v6;
};

/**
 * Signals in message ams_s3_voltages_2.
 *
 * All signal values are as on the CAN bus.
 */
struct can1_ams_s3_voltages_2_t {
    /**
     * Range: 0..255.1020408163265306122448980 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t s3v7;

    /**
     * Range: 0..255.1020408163265306122448980 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t s3v8;

    /**
     * Range: 0..255.1020408163265306122448980 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t s3v9;

    /**
     * Range: 0..255.1020408163265306122448980 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t s3v10;

    /**
     * Range: 0..255.1020408163265306122448980 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t s3v11;
};

/**
 * Signals in message ams_s4_voltages_1.
 *
 * All signal values are as on the CAN bus.
 */
struct can1_ams_s4_voltages_1_t {
    /**
     * Range: 0..255.1020408163265306122448980 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t s4v1;

    /**
     * Range: 0..255.1020408163265306122448980 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t s4v2;

    /**
     * Range: 0..255.1020408163265306122448980 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t s4v3;

    /**
     * Range: 0..255.1020408163265306122448980 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t s4v4;

    /**
     * Range: 0..255.1020408163265306122448980 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t s4v5;

    /**
     * Range: 0..255.1020408163265306122448980 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t s4v6;
};

/**
 * Signals in message ams_s4_voltages_2.
 *
 * All signal values are as on the CAN bus.
 */
struct can1_ams_s4_voltages_2_t {
    /**
     * Range: 0..255.1020408163265306122448980 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t s4v7;

    /**
     * Range: 0..255.1020408163265306122448980 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t s4v8;

    /**
     * Range: 0..255.1020408163265306122448980 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t s4v9;

    /**
     * Range: 0..255.1020408163265306122448980 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t s4v10;

    /**
     * Range: 0..255.1020408163265306122448980 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t s4v11;
};

/**
 * Signals in message ams_s5_voltages_1.
 *
 * All signal values are as on the CAN bus.
 */
struct can1_ams_s5_voltages_1_t {
    /**
     * Range: 0..255.1020408163265306122448980 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t s5v1;

    /**
     * Range: 0..255.1020408163265306122448980 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t s5v2;

    /**
     * Range: 0..255.1020408163265306122448980 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t s5v3;

    /**
     * Range: 0..255.1020408163265306122448980 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t s5v4;

    /**
     * Range: 0..255.1020408163265306122448980 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t s5v5;

    /**
     * Range: 0..255.1020408163265306122448980 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t s5v6;
};

/**
 * Signals in message ams_s5_voltages_2.
 *
 * All signal values are as on the CAN bus.
 */
struct can1_ams_s5_voltages_2_t {
    /**
     * Range: 0..255.1020408163265306122448980 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t s5v7;

    /**
     * Range: 0..255.1020408163265306122448980 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t s5v8;

    /**
     * Range: 0..255.1020408163265306122448980 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t s5v9;

    /**
     * Range: 0..255.1020408163265306122448980 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t s5v10;

    /**
     * Range: 0..255.1020408163265306122448980 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t s5v11;
};

/**
 * Signals in message ams_s6_voltages_1.
 *
 * All signal values are as on the CAN bus.
 */
struct can1_ams_s6_voltages_1_t {
    /**
     * Range: 0..255.1020408163265306122448980 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t s6v1;

    /**
     * Range: 0..255.1020408163265306122448980 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t s6v2;

    /**
     * Range: 0..255.1020408163265306122448980 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t s6v3;

    /**
     * Range: 0..255.1020408163265306122448980 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t s6v4;

    /**
     * Range: 0..255.1020408163265306122448980 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t s6v5;

    /**
     * Range: 0..255.1020408163265306122448980 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t s6v6;
};

/**
 * Signals in message ams_s6_voltages_2.
 *
 * All signal values are as on the CAN bus.
 */
struct can1_ams_s6_voltages_2_t {
    /**
     * Range: 0..255.1020408163265306122448980 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t s6v7;

    /**
     * Range: 0..255.1020408163265306122448980 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t s6v8;

    /**
     * Range: 0..255.1020408163265306122448980 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t s6v9;

    /**
     * Range: 0..255.1020408163265306122448980 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t s6v10;

    /**
     * Range: 0..255.1020408163265306122448980 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t s6v11;
};

/**
 * Signals in message ams_s7_voltages_1.
 *
 * All signal values are as on the CAN bus.
 */
struct can1_ams_s7_voltages_1_t {
    /**
     * Range: 0..255.1020408163265306122448980 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t s7v1;

    /**
     * Range: 0..255.1020408163265306122448980 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t s7v2;

    /**
     * Range: 0..255.1020408163265306122448980 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t s7v3;

    /**
     * Range: 0..255.1020408163265306122448980 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t s7v4;

    /**
     * Range: 0..255.1020408163265306122448980 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t s7v5;

    /**
     * Range: 0..255.1020408163265306122448980 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t s7v6;
};

/**
 * Signals in message ams_s7_voltages_2.
 *
 * All signal values are as on the CAN bus.
 */
struct can1_ams_s7_voltages_2_t {
    /**
     * Range: 0..255.1020408163265306122448980 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t s7v7;

    /**
     * Range: 0..255.1020408163265306122448980 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t s7v8;

    /**
     * Range: 0..255.1020408163265306122448980 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t s7v9;

    /**
     * Range: 0..255.1020408163265306122448980 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t s7v10;

    /**
     * Range: 0..255.1020408163265306122448980 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t s7v11;
};

/**
 * Signals in message ams_s8_voltages_1.
 *
 * All signal values are as on the CAN bus.
 */
struct can1_ams_s8_voltages_1_t {
    /**
     * Range: 0..255.1020408163265306122448980 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t s8v1;

    /**
     * Range: 0..255.1020408163265306122448980 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t s8v2;

    /**
     * Range: 0..255.1020408163265306122448980 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t s8v3;

    /**
     * Range: 0..255.1020408163265306122448980 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t s8v4;

    /**
     * Range: 0..255.1020408163265306122448980 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t s8v5;

    /**
     * Range: 0..255.1020408163265306122448980 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t s8v6;
};

/**
 * Signals in message ams_s8_voltages_2.
 *
 * All signal values are as on the CAN bus.
 */
struct can1_ams_s8_voltages_2_t {
    /**
     * Range: 0..255.1020408163265306122448980 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t s8v7;

    /**
     * Range: 0..255.1020408163265306122448980 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t s8v8;

    /**
     * Range: 0..255.1020408163265306122448980 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t s8v9;

    /**
     * Range: 0..255.1020408163265306122448980 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t s8v10;

    /**
     * Range: 0..255.1020408163265306122448980 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t s8v11;
};

/**
 * Signals in message ams_s9_voltages_1.
 *
 * All signal values are as on the CAN bus.
 */
struct can1_ams_s9_voltages_1_t {
    /**
     * Range: 0..255.1020408163265306122448980 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t s9v1;

    /**
     * Range: 0..255.1020408163265306122448980 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t s9v2;

    /**
     * Range: 0..255.1020408163265306122448980 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t s9v3;

    /**
     * Range: 0..255.1020408163265306122448980 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t s9v4;

    /**
     * Range: 0..255.1020408163265306122448980 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t s9v5;

    /**
     * Range: 0..255.1020408163265306122448980 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t s9v6;
};

/**
 * Signals in message ams_s9_voltages_2.
 *
 * From competition handbook
 *
 * All signal values are as on the CAN bus.
 */
struct can1_ams_s9_voltages_2_t {
    /**
     * Range: 0..255.1020408163265306122448980 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t s9v7;

    /**
     * Range: 0..255.1020408163265306122448980 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t s9v8;

    /**
     * Range: 0..255.1020408163265306122448980 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t s9v9;

    /**
     * Range: 0..255.1020408163265306122448980 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t s9v10;

    /**
     * Range: 0..255.1020408163265306122448980 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t s9v11;
};

/**
 * Signals in message ams_s10_voltages_1.
 *
 * All signal values are as on the CAN bus.
 */
struct can1_ams_s10_voltages_1_t {
    /**
     * Range: 0..255.1020408163265306122448980 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t s10v1;

    /**
     * Range: 0..255.1020408163265306122448980 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t s10v2;

    /**
     * Range: 0..255.1020408163265306122448980 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t s10v3;

    /**
     * Range: 0..255.1020408163265306122448980 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t s10v4;

    /**
     * Range: 0..255.1020408163265306122448980 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t s10v5;

    /**
     * Range: 0..255.1020408163265306122448980 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t s10v6;
};

/**
 * Signals in message ams_s10_voltages_2.
 *
 * All signal values are as on the CAN bus.
 */
struct can1_ams_s10_voltages_2_t {
    /**
     * Range: 0..255.1020408163265306122448980 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t s10v7;

    /**
     * Range: 0..255.1020408163265306122448980 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t s10v8;

    /**
     * Range: 0..255.1020408163265306122448980 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t s10v9;

    /**
     * Range: 0..255.1020408163265306122448980 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t s10v10;

    /**
     * Range: 0..255.1020408163265306122448980 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t s10v11;
};

/**
 * Signals in message ams_s11_voltages_1.
 *
 * All signal values are as on the CAN bus.
 */
struct can1_ams_s11_voltages_1_t {
    /**
     * Range: 0..255.1020408163265306122448980 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t s11v1;

    /**
     * Range: 0..255.1020408163265306122448980 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t s11v2;

    /**
     * Range: 0..255.1020408163265306122448980 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t s11v3;

    /**
     * Range: 0..255.1020408163265306122448980 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t s11v4;

    /**
     * Range: 0..255.1020408163265306122448980 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t s11v5;

    /**
     * Range: 0..255.1020408163265306122448980 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t s11v6;
};

/**
 * Signals in message ams_s11_voltages_2.
 *
 * All signal values are as on the CAN bus.
 */
struct can1_ams_s11_voltages_2_t {
    /**
     * Range: 0..255.1020408163265306122448980 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t s11v7;

    /**
     * Range: 0..255.1020408163265306122448980 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t s11v8;

    /**
     * Range: 0..255.1020408163265306122448980 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t s11v9;

    /**
     * Range: 0..255.1020408163265306122448980 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t s11v10;

    /**
     * Range: 0..255.1020408163265306122448980 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t s11v11;
};

/**
 * Signals in message ams_s12_voltages_1.
 *
 * All signal values are as on the CAN bus.
 */
struct can1_ams_s12_voltages_1_t {
    /**
     * Range: 0..255.1020408163265306122448980 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t s12v1;

    /**
     * Range: 0..255.1020408163265306122448980 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t s12v2;

    /**
     * Range: 0..255.1020408163265306122448980 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t s12v3;

    /**
     * Range: 0..255.1020408163265306122448980 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t s12v4;

    /**
     * Range: 0..255.1020408163265306122448980 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t s12v5;

    /**
     * Range: 0..255.1020408163265306122448980 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t s12v6;
};

/**
 * Signals in message ams_s12_voltages_2.
 *
 * All signal values are as on the CAN bus.
 */
struct can1_ams_s12_voltages_2_t {
    /**
     * Range: 0..255.1020408163265306122448980 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t s12v7;

    /**
     * Range: 0..255.1020408163265306122448980 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t s12v8;

    /**
     * Range: 0..255.1020408163265306122448980 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t s12v9;

    /**
     * Range: 0..255.1020408163265306122448980 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t s12v10;

    /**
     * Range: 0..255.1020408163265306122448980 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t s12v11;
};

/**
 * Signals in message ivt_improved_status.
 *
 * All signal values are as on the CAN bus.
 */
struct can1_ivt_improved_status_t {
    /**
     * Voltage measurement on battery side
     *
     * Range: 0..600 (0..600 V)
     * Scale: 1
     * Offset: 0
     */
    uint16_t ivt_voltage_battery;

    /**
     * Voltage measurement on vehicle side
     *
     * Range: 0..600 (0..600 V)
     * Scale: 1
     * Offset: 0
     */
    uint16_t ivt_voltage_vehicle;

    /**
     * Current measurement
     *
     * Range: -50..200 (-50..200 A)
     * Scale: 1
     * Offset: 0
     */
    int16_t ivt_current;

    /**
     * Temperature Measurement on the HV+ side of board
     *
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t temp_h_vplus;

    /**
     * Temperature Measurement on HV- side of battery
     *
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t temp_h_vminus;
};

/**
 * Signals in message res_recieve_PDO.
 *
 * From competition handbook
 *
 * All signal values are as on the CAN bus.
 */
struct can1_res_recieve_pdo_t {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;
};

/**
 * Signals in message res_transmit_SDO.
 *
 * From competition handbook
 *
 * All signal values are as on the CAN bus.
 */
struct can1_res_transmit_sdo_t {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;
};

/**
 * Signals in message res_recieve_SDO.
 *
 * From competition handbook
 *
 * All signal values are as on the CAN bus.
 */
struct can1_res_recieve_sdo_t {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;
};

/**
 * Signals in message res_transmit_LSS.
 *
 * From competition handbook
 *
 * All signal values are as on the CAN bus.
 */
struct can1_res_transmit_lss_t {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;
};

/**
 * Signals in message res_recieve_LSS.
 *
 * From competition handbook
 *
 * All signal values are as on the CAN bus.
 */
struct can1_res_recieve_lss_t {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;
};

/**
 * Pack message ams_status_1.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can1_ams_status_1_pack(
    uint8_t *dst_p,
    const struct can1_ams_status_1_t *src_p,
    size_t size);

/**
 * Unpack message ams_status_1.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can1_ams_status_1_unpack(
    struct can1_ams_status_1_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_status_1_charging_status_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_status_1_charging_status_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_status_1_charging_status_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_status_1_air1_closed_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_status_1_air1_closed_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_status_1_air1_closed_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_status_1_air2_closed_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_status_1_air2_closed_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_status_1_air2_closed_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_status_1_sc_closed_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_status_1_sc_closed_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_status_1_sc_closed_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_status_1_pre_charge_status_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_status_1_pre_charge_status_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_status_1_pre_charge_status_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_status_1_ams_error_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_status_1_ams_error_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_status_1_ams_error_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_status_1_imd_error_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_status_1_imd_error_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_status_1_imd_error_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_status_1_state_of_charge_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_status_1_state_of_charge_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_status_1_state_of_charge_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_status_1_min_cell_voltage_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_status_1_min_cell_voltage_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_status_1_min_cell_voltage_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_status_1_max_cell_voltage_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_status_1_max_cell_voltage_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_status_1_max_cell_voltage_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_ams_status_1_min_cell_temperature_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_status_1_min_cell_temperature_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_status_1_min_cell_temperature_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_ams_status_1_max_cell_temperature_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_status_1_max_cell_temperature_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_status_1_max_cell_temperature_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_status_1_fan_speed_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_status_1_fan_speed_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_status_1_fan_speed_is_in_range(uint8_t value);

/**
 * Pack message ams_state.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can1_ams_state_pack(
    uint8_t *dst_p,
    const struct can1_ams_state_t *src_p,
    size_t size);

/**
 * Unpack message ams_state.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can1_ams_state_unpack(
    struct can1_ams_state_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint64_t can1_ams_state_state_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_state_state_decode(uint64_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_state_state_is_in_range(uint64_t value);

/**
 * Pack message ams_error.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can1_ams_error_pack(
    uint8_t *dst_p,
    const struct can1_ams_error_t *src_p,
    size_t size);

/**
 * Unpack message ams_error.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can1_ams_error_unpack(
    struct can1_ams_error_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t can1_ams_error_error_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_error_error_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_error_error_is_in_range(uint32_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t can1_ams_error_reset_cause_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_error_reset_cause_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_error_reset_cause_is_in_range(uint32_t value);

/**
 * Pack message dv_driving_dynamics_1.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can1_dv_driving_dynamics_1_pack(
    uint8_t *dst_p,
    const struct can1_dv_driving_dynamics_1_t *src_p,
    size_t size);

/**
 * Unpack message dv_driving_dynamics_1.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can1_dv_driving_dynamics_1_unpack(
    struct can1_dv_driving_dynamics_1_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_dv_driving_dynamics_1_speed_actual_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_dv_driving_dynamics_1_speed_actual_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_dv_driving_dynamics_1_speed_actual_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_dv_driving_dynamics_1_speed_target_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_dv_driving_dynamics_1_speed_target_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_dv_driving_dynamics_1_speed_target_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int8_t can1_dv_driving_dynamics_1_steering_angle_actual_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_dv_driving_dynamics_1_steering_angle_actual_decode(int8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_dv_driving_dynamics_1_steering_angle_actual_is_in_range(int8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int8_t can1_dv_driving_dynamics_1_steering_angle_target_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_dv_driving_dynamics_1_steering_angle_target_decode(int8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_dv_driving_dynamics_1_steering_angle_target_is_in_range(int8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_dv_driving_dynamics_1_brake_hydr_actual_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_dv_driving_dynamics_1_brake_hydr_actual_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_dv_driving_dynamics_1_brake_hydr_actual_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_dv_driving_dynamics_1_brake_hydr_target_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_dv_driving_dynamics_1_brake_hydr_target_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_dv_driving_dynamics_1_brake_hydr_target_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int8_t can1_dv_driving_dynamics_1_motor_moment_actual_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_dv_driving_dynamics_1_motor_moment_actual_decode(int8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_dv_driving_dynamics_1_motor_moment_actual_is_in_range(int8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int8_t can1_dv_driving_dynamics_1_motor_moment_target_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_dv_driving_dynamics_1_motor_moment_target_decode(int8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_dv_driving_dynamics_1_motor_moment_target_is_in_range(int8_t value);

/**
 * Pack message dv_driving_dynamics_2.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can1_dv_driving_dynamics_2_pack(
    uint8_t *dst_p,
    const struct can1_dv_driving_dynamics_2_t *src_p,
    size_t size);

/**
 * Unpack message dv_driving_dynamics_2.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can1_dv_driving_dynamics_2_unpack(
    struct can1_dv_driving_dynamics_2_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_dv_driving_dynamics_2_acceleration_longitudinal_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_dv_driving_dynamics_2_acceleration_longitudinal_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_dv_driving_dynamics_2_acceleration_longitudinal_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_dv_driving_dynamics_2_acceleration_lateral_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_dv_driving_dynamics_2_acceleration_lateral_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_dv_driving_dynamics_2_acceleration_lateral_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_dv_driving_dynamics_2_yaw_rate_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_dv_driving_dynamics_2_yaw_rate_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_dv_driving_dynamics_2_yaw_rate_is_in_range(int16_t value);

/**
 * Pack message dv_system_status.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can1_dv_system_status_pack(
    uint8_t *dst_p,
    const struct can1_dv_system_status_t *src_p,
    size_t size);

/**
 * Unpack message dv_system_status.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can1_dv_system_status_unpack(
    struct can1_dv_system_status_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_dv_system_status_as_state_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_dv_system_status_as_state_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_dv_system_status_as_state_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_dv_system_status_ebs_state_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_dv_system_status_ebs_state_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_dv_system_status_ebs_state_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_dv_system_status_ami_state_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_dv_system_status_ami_state_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_dv_system_status_ami_state_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_dv_system_status_steering_state_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_dv_system_status_steering_state_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_dv_system_status_steering_state_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_dv_system_status_service_brake_state_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_dv_system_status_service_brake_state_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_dv_system_status_service_brake_state_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_dv_system_status_lap_counter_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_dv_system_status_lap_counter_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_dv_system_status_lap_counter_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_dv_system_status_cones_count_actual_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_dv_system_status_cones_count_actual_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_dv_system_status_cones_count_actual_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t can1_dv_system_status_cones_count_all_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_dv_system_status_cones_count_all_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_dv_system_status_cones_count_all_is_in_range(uint32_t value);

/**
 * Pack message mcu_set_ecu_indicator_points.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can1_mcu_set_ecu_indicator_points_pack(
    uint8_t *dst_p,
    const struct can1_mcu_set_ecu_indicator_points_t *src_p,
    size_t size);

/**
 * Unpack message mcu_set_ecu_indicator_points.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can1_mcu_set_ecu_indicator_points_unpack(
    struct can1_mcu_set_ecu_indicator_points_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_mcu_set_ecu_indicator_points_brake_light_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_mcu_set_ecu_indicator_points_brake_light_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_mcu_set_ecu_indicator_points_brake_light_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_mcu_set_ecu_indicator_points_r2d_sound_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_mcu_set_ecu_indicator_points_r2d_sound_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_mcu_set_ecu_indicator_points_r2d_sound_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_mcu_set_ecu_indicator_points_assi_yellow_right_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_mcu_set_ecu_indicator_points_assi_yellow_right_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_mcu_set_ecu_indicator_points_assi_yellow_right_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_mcu_set_ecu_indicator_points_assi_yellow_left_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_mcu_set_ecu_indicator_points_assi_yellow_left_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_mcu_set_ecu_indicator_points_assi_yellow_left_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_mcu_set_ecu_indicator_points_assi_yellow_rear_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_mcu_set_ecu_indicator_points_assi_yellow_rear_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_mcu_set_ecu_indicator_points_assi_yellow_rear_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_mcu_set_ecu_indicator_points_assi_blue_right_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_mcu_set_ecu_indicator_points_assi_blue_right_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_mcu_set_ecu_indicator_points_assi_blue_right_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_mcu_set_ecu_indicator_points_assi_blue_left_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_mcu_set_ecu_indicator_points_assi_blue_left_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_mcu_set_ecu_indicator_points_assi_blue_left_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_mcu_set_ecu_indicator_points_assi_blue_rear_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_mcu_set_ecu_indicator_points_assi_blue_rear_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_mcu_set_ecu_indicator_points_assi_blue_rear_is_in_range(uint8_t value);

/**
 * Pack message mcu_set_dbu_indicator_points.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can1_mcu_set_dbu_indicator_points_pack(
    uint8_t *dst_p,
    const struct can1_mcu_set_dbu_indicator_points_t *src_p,
    size_t size);

/**
 * Unpack message mcu_set_dbu_indicator_points.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can1_mcu_set_dbu_indicator_points_unpack(
    struct can1_mcu_set_dbu_indicator_points_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_mcu_set_dbu_indicator_points_ts_indicator_on_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_mcu_set_dbu_indicator_points_ts_indicator_on_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_mcu_set_dbu_indicator_points_ts_indicator_on_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_mcu_set_dbu_indicator_points_r2d_indicator_on_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_mcu_set_dbu_indicator_points_r2d_indicator_on_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_mcu_set_dbu_indicator_points_r2d_indicator_on_is_in_range(uint8_t value);

/**
 * Pack message res_status.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can1_res_status_pack(
    uint8_t *dst_p,
    const struct can1_res_status_t *src_p,
    size_t size);

/**
 * Unpack message res_status.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can1_res_status_unpack(
    struct can1_res_status_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_res_status_e_stop_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_res_status_e_stop_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_res_status_e_stop_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_res_status_switch_status_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_res_status_switch_status_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_res_status_switch_status_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_res_status_button_status_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_res_status_button_status_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_res_status_button_status_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_res_status_e_stop_redundancy_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_res_status_e_stop_redundancy_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_res_status_e_stop_redundancy_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_res_status_radio_quality_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_res_status_radio_quality_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_res_status_radio_quality_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_res_status_radio_state_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_res_status_radio_state_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_res_status_radio_state_is_in_range(uint8_t value);

/**
 * Pack message res_initialization.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can1_res_initialization_pack(
    uint8_t *dst_p,
    const struct can1_res_initialization_t *src_p,
    size_t size);

/**
 * Unpack message res_initialization.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can1_res_initialization_unpack(
    struct can1_res_initialization_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_res_initialization_res_init_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_res_initialization_res_init_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_res_initialization_res_init_is_in_range(uint8_t value);

/**
 * Pack message res_nmt_node_control.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can1_res_nmt_node_control_pack(
    uint8_t *dst_p,
    const struct can1_res_nmt_node_control_t *src_p,
    size_t size);

/**
 * Unpack message res_nmt_node_control.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can1_res_nmt_node_control_unpack(
    struct can1_res_nmt_node_control_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_res_nmt_node_control_requested_state_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_res_nmt_node_control_requested_state_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_res_nmt_node_control_requested_state_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_res_nmt_node_control_node_id_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_res_nmt_node_control_node_id_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_res_nmt_node_control_node_id_is_in_range(uint8_t value);

/**
 * Pack message swu_status.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can1_swu_status_pack(
    uint8_t *dst_p,
    const struct can1_swu_status_t *src_p,
    size_t size);

/**
 * Unpack message swu_status.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can1_swu_status_unpack(
    struct can1_swu_status_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_swu_status_button_1_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_swu_status_button_1_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_swu_status_button_1_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_swu_status_button_2_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_swu_status_button_2_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_swu_status_button_2_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_swu_status_button_3_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_swu_status_button_3_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_swu_status_button_3_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_swu_status_button_4_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_swu_status_button_4_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_swu_status_button_4_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_swu_status_button_5_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_swu_status_button_5_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_swu_status_button_5_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_swu_status_button_6_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_swu_status_button_6_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_swu_status_button_6_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_swu_status_rotary_switch_1_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_swu_status_rotary_switch_1_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_swu_status_rotary_switch_1_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_swu_status_rotary_switch_2_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_swu_status_rotary_switch_2_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_swu_status_rotary_switch_2_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_swu_status_rotary_switch_3_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_swu_status_rotary_switch_3_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_swu_status_rotary_switch_3_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_swu_status_rotary_switch_4_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_swu_status_rotary_switch_4_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_swu_status_rotary_switch_4_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_swu_status_encoder_1_button_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_swu_status_encoder_1_button_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_swu_status_encoder_1_button_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_swu_status_encoder_2_button_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_swu_status_encoder_2_button_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_swu_status_encoder_2_button_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int8_t can1_swu_status_encoder_1_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_swu_status_encoder_1_decode(int8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_swu_status_encoder_1_is_in_range(int8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int8_t can1_swu_status_encoder_2_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_swu_status_encoder_2_decode(int8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_swu_status_encoder_2_is_in_range(int8_t value);

/**
 * Pack message dbu_status_1.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can1_dbu_status_1_pack(
    uint8_t *dst_p,
    const struct can1_dbu_status_1_t *src_p,
    size_t size);

/**
 * Unpack message dbu_status_1.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can1_dbu_status_1_unpack(
    struct can1_dbu_status_1_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_dbu_status_1_activate_ts_button_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_dbu_status_1_activate_ts_button_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_dbu_status_1_activate_ts_button_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_dbu_status_1_ready_to_drive_button_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_dbu_status_1_ready_to_drive_button_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_dbu_status_1_ready_to_drive_button_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_dbu_status_1_selected_mission_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_dbu_status_1_selected_mission_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_dbu_status_1_selected_mission_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_dbu_status_1_dbu_temperature_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_dbu_status_1_dbu_temperature_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_dbu_status_1_dbu_temperature_is_in_range(int16_t value);

/**
 * Pack message lv_power_signal.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can1_lv_power_signal_pack(
    uint8_t *dst_p,
    const struct can1_lv_power_signal_t *src_p,
    size_t size);

/**
 * Unpack message lv_power_signal.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can1_lv_power_signal_unpack(
    struct can1_lv_power_signal_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_lv_power_signal_lv_on_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_lv_power_signal_lv_on_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_lv_power_signal_lv_on_is_in_range(uint8_t value);

/**
 * Pack message lv_bms_data_a.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can1_lv_bms_data_a_pack(
    uint8_t *dst_p,
    const struct can1_lv_bms_data_a_t *src_p,
    size_t size);

/**
 * Unpack message lv_bms_data_a.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can1_lv_bms_data_a_unpack(
    struct can1_lv_bms_data_a_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_lv_bms_data_a_data_multiplexor_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_lv_bms_data_a_data_multiplexor_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_lv_bms_data_a_data_multiplexor_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_lv_bms_data_a_voltage_cell_1_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_lv_bms_data_a_voltage_cell_1_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_lv_bms_data_a_voltage_cell_1_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_lv_bms_data_a_soc_1_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_lv_bms_data_a_soc_1_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_lv_bms_data_a_soc_1_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_lv_bms_data_a_therm1_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_lv_bms_data_a_therm1_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_lv_bms_data_a_therm1_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can1_lv_bms_data_a_current_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_lv_bms_data_a_current_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_lv_bms_data_a_current_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_lv_bms_data_a_voltage_cell_2_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_lv_bms_data_a_voltage_cell_2_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_lv_bms_data_a_voltage_cell_2_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_lv_bms_data_a_soc_2_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_lv_bms_data_a_soc_2_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_lv_bms_data_a_soc_2_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_lv_bms_data_a_therm2_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_lv_bms_data_a_therm2_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_lv_bms_data_a_therm2_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t can1_lv_bms_data_a_current_count_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_lv_bms_data_a_current_count_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_lv_bms_data_a_current_count_is_in_range(uint32_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_lv_bms_data_a_voltage_cell_3_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_lv_bms_data_a_voltage_cell_3_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_lv_bms_data_a_voltage_cell_3_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_lv_bms_data_a_soc_3_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_lv_bms_data_a_soc_3_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_lv_bms_data_a_soc_3_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_lv_bms_data_a_voltage_cell_4_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_lv_bms_data_a_voltage_cell_4_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_lv_bms_data_a_voltage_cell_4_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_lv_bms_data_a_soc_4_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_lv_bms_data_a_soc_4_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_lv_bms_data_a_soc_4_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_lv_bms_data_a_therm3_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_lv_bms_data_a_therm3_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_lv_bms_data_a_therm3_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_lv_bms_data_a_voltage_cell_5_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_lv_bms_data_a_voltage_cell_5_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_lv_bms_data_a_voltage_cell_5_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_lv_bms_data_a_soc_5_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_lv_bms_data_a_soc_5_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_lv_bms_data_a_soc_5_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_lv_bms_data_a_therm4_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_lv_bms_data_a_therm4_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_lv_bms_data_a_therm4_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t can1_lv_bms_data_a_energy_count_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_lv_bms_data_a_energy_count_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_lv_bms_data_a_energy_count_is_in_range(uint32_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_lv_bms_data_a_voltage_cell_6_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_lv_bms_data_a_voltage_cell_6_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_lv_bms_data_a_voltage_cell_6_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_lv_bms_data_a_soc_6_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_lv_bms_data_a_soc_6_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_lv_bms_data_a_soc_6_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_lv_bms_data_a_therm5_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_lv_bms_data_a_therm5_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_lv_bms_data_a_therm5_is_in_range(int16_t value);

/**
 * Pack message lv_bms_status_a.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can1_lv_bms_status_a_pack(
    uint8_t *dst_p,
    const struct can1_lv_bms_status_a_t *src_p,
    size_t size);

/**
 * Unpack message lv_bms_status_a.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can1_lv_bms_status_a_unpack(
    struct can1_lv_bms_status_a_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_lv_bms_status_a_lv_bms_error_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_lv_bms_status_a_lv_bms_error_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_lv_bms_status_a_lv_bms_error_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_lv_bms_status_a_soc_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_lv_bms_status_a_soc_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_lv_bms_status_a_soc_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can1_lv_bms_status_a_current_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_lv_bms_status_a_current_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_lv_bms_status_a_current_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can1_lv_bms_status_a_voltage_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_lv_bms_status_a_voltage_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_lv_bms_status_a_voltage_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_lv_bms_status_a_temperature_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_lv_bms_status_a_temperature_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_lv_bms_status_a_temperature_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_lv_bms_status_a_not_battery_output_enable_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_lv_bms_status_a_not_battery_output_enable_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_lv_bms_status_a_not_battery_output_enable_is_in_range(uint8_t value);

/**
 * Pack message ams_temperatures.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can1_ams_temperatures_pack(
    uint8_t *dst_p,
    const struct can1_ams_temperatures_t *src_p,
    size_t size);

/**
 * Unpack message ams_temperatures.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can1_ams_temperatures_unpack(
    struct can1_ams_temperatures_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_ams_temperatures_pre_charge_resistor_temperature_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_temperatures_pre_charge_resistor_temperature_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_temperatures_pre_charge_resistor_temperature_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_ams_temperatures_fuse_resistor_temperature_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_temperatures_fuse_resistor_temperature_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_temperatures_fuse_resistor_temperature_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_ams_temperatures_aux_1_temperature_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_temperatures_aux_1_temperature_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_temperatures_aux_1_temperature_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_ams_temperatures_aux_2_temperature_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_temperatures_aux_2_temperature_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_temperatures_aux_2_temperature_is_in_range(int16_t value);

/**
 * Pack message ams_cell_voltages.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can1_ams_cell_voltages_pack(
    uint8_t *dst_p,
    const struct can1_ams_cell_voltages_t *src_p,
    size_t size);

/**
 * Unpack message ams_cell_voltages.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can1_ams_cell_voltages_unpack(
    struct can1_ams_cell_voltages_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_cell_voltages_voltage_multiplexor_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_voltages_voltage_multiplexor_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_voltages_voltage_multiplexor_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_cell_voltages_v1s1_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_voltages_v1s1_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_voltages_v1s1_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_cell_voltages_v7s1_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_voltages_v7s1_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_voltages_v7s1_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_cell_voltages_v1s2_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_voltages_v1s2_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_voltages_v1s2_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_cell_voltages_v7s2_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_voltages_v7s2_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_voltages_v7s2_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_cell_voltages_v1s3_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_voltages_v1s3_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_voltages_v1s3_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_cell_voltages_v7s3_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_voltages_v7s3_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_voltages_v7s3_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_cell_voltages_v1s4_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_voltages_v1s4_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_voltages_v1s4_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_cell_voltages_v7s4_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_voltages_v7s4_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_voltages_v7s4_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_cell_voltages_v1s5_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_voltages_v1s5_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_voltages_v1s5_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_cell_voltages_v7s5_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_voltages_v7s5_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_voltages_v7s5_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_cell_voltages_v1s6_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_voltages_v1s6_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_voltages_v1s6_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_cell_voltages_v7s6_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_voltages_v7s6_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_voltages_v7s6_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_cell_voltages_v1s7_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_voltages_v1s7_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_voltages_v1s7_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_cell_voltages_v7s7_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_voltages_v7s7_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_voltages_v7s7_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_cell_voltages_v1s8_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_voltages_v1s8_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_voltages_v1s8_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_cell_voltages_v7s8_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_voltages_v7s8_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_voltages_v7s8_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_cell_voltages_v1s9_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_voltages_v1s9_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_voltages_v1s9_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_cell_voltages_v7s9_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_voltages_v7s9_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_voltages_v7s9_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_cell_voltages_v1s10_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_voltages_v1s10_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_voltages_v1s10_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_cell_voltages_v7s10_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_voltages_v7s10_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_voltages_v7s10_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_cell_voltages_v1s11_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_voltages_v1s11_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_voltages_v1s11_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_cell_voltages_v7s11_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_voltages_v7s11_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_voltages_v7s11_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_cell_voltages_v1s12_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_voltages_v1s12_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_voltages_v1s12_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_cell_voltages_v7s12_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_voltages_v7s12_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_voltages_v7s12_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_cell_voltages_v2s1_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_voltages_v2s1_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_voltages_v2s1_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_cell_voltages_v8s1_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_voltages_v8s1_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_voltages_v8s1_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_cell_voltages_v2s2_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_voltages_v2s2_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_voltages_v2s2_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_cell_voltages_v8s2_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_voltages_v8s2_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_voltages_v8s2_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_cell_voltages_v2s3_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_voltages_v2s3_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_voltages_v2s3_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_cell_voltages_v8s3_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_voltages_v8s3_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_voltages_v8s3_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_cell_voltages_v2s4_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_voltages_v2s4_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_voltages_v2s4_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_cell_voltages_v8s4_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_voltages_v8s4_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_voltages_v8s4_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_cell_voltages_v2s5_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_voltages_v2s5_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_voltages_v2s5_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_cell_voltages_v8s5_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_voltages_v8s5_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_voltages_v8s5_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_cell_voltages_v2s6_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_voltages_v2s6_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_voltages_v2s6_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_cell_voltages_v8s6_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_voltages_v8s6_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_voltages_v8s6_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_cell_voltages_v2s7_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_voltages_v2s7_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_voltages_v2s7_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_cell_voltages_v8s7_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_voltages_v8s7_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_voltages_v8s7_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_cell_voltages_v2s8_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_voltages_v2s8_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_voltages_v2s8_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_cell_voltages_v8s8_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_voltages_v8s8_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_voltages_v8s8_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_cell_voltages_v2s9_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_voltages_v2s9_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_voltages_v2s9_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_cell_voltages_v8s9_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_voltages_v8s9_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_voltages_v8s9_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_cell_voltages_v2s10_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_voltages_v2s10_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_voltages_v2s10_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_cell_voltages_v8s10_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_voltages_v8s10_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_voltages_v8s10_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_cell_voltages_v2s11_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_voltages_v2s11_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_voltages_v2s11_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_cell_voltages_v8s11_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_voltages_v8s11_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_voltages_v8s11_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_cell_voltages_v2s12_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_voltages_v2s12_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_voltages_v2s12_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_cell_voltages_v8s12_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_voltages_v8s12_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_voltages_v8s12_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_cell_voltages_v3s1_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_voltages_v3s1_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_voltages_v3s1_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_cell_voltages_v9s1_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_voltages_v9s1_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_voltages_v9s1_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_cell_voltages_v3s2_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_voltages_v3s2_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_voltages_v3s2_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_cell_voltages_v9s2_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_voltages_v9s2_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_voltages_v9s2_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_cell_voltages_v3s3_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_voltages_v3s3_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_voltages_v3s3_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_cell_voltages_v9s3_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_voltages_v9s3_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_voltages_v9s3_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_cell_voltages_v3s4_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_voltages_v3s4_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_voltages_v3s4_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_cell_voltages_v9s4_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_voltages_v9s4_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_voltages_v9s4_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_cell_voltages_v3s5_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_voltages_v3s5_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_voltages_v3s5_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_cell_voltages_v9s5_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_voltages_v9s5_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_voltages_v9s5_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_cell_voltages_v3s6_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_voltages_v3s6_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_voltages_v3s6_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_cell_voltages_v9s6_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_voltages_v9s6_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_voltages_v9s6_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_cell_voltages_v3s7_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_voltages_v3s7_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_voltages_v3s7_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_cell_voltages_v9s7_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_voltages_v9s7_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_voltages_v9s7_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_cell_voltages_v3s8_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_voltages_v3s8_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_voltages_v3s8_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_cell_voltages_v9s8_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_voltages_v9s8_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_voltages_v9s8_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_cell_voltages_v3s9_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_voltages_v3s9_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_voltages_v3s9_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_cell_voltages_v9s9_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_voltages_v9s9_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_voltages_v9s9_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_cell_voltages_v3s10_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_voltages_v3s10_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_voltages_v3s10_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_cell_voltages_v9s10_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_voltages_v9s10_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_voltages_v9s10_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_cell_voltages_v3s11_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_voltages_v3s11_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_voltages_v3s11_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_cell_voltages_v9s11_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_voltages_v9s11_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_voltages_v9s11_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_cell_voltages_v3s12_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_voltages_v3s12_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_voltages_v3s12_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_cell_voltages_v9s12_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_voltages_v9s12_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_voltages_v9s12_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_cell_voltages_v4s1_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_voltages_v4s1_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_voltages_v4s1_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_cell_voltages_v10s1_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_voltages_v10s1_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_voltages_v10s1_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_cell_voltages_v4s2_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_voltages_v4s2_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_voltages_v4s2_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_cell_voltages_v10s2_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_voltages_v10s2_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_voltages_v10s2_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_cell_voltages_v4s3_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_voltages_v4s3_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_voltages_v4s3_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_cell_voltages_v10s3_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_voltages_v10s3_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_voltages_v10s3_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_cell_voltages_v4s4_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_voltages_v4s4_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_voltages_v4s4_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_cell_voltages_v10s4_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_voltages_v10s4_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_voltages_v10s4_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_cell_voltages_v4s5_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_voltages_v4s5_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_voltages_v4s5_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_cell_voltages_v10s5_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_voltages_v10s5_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_voltages_v10s5_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_cell_voltages_v4s6_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_voltages_v4s6_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_voltages_v4s6_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_cell_voltages_v10s6_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_voltages_v10s6_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_voltages_v10s6_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_cell_voltages_v4s7_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_voltages_v4s7_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_voltages_v4s7_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_cell_voltages_v10s7_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_voltages_v10s7_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_voltages_v10s7_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_cell_voltages_v4s8_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_voltages_v4s8_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_voltages_v4s8_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_cell_voltages_v10s8_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_voltages_v10s8_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_voltages_v10s8_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_cell_voltages_v4s9_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_voltages_v4s9_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_voltages_v4s9_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_cell_voltages_v10s9_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_voltages_v10s9_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_voltages_v10s9_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_cell_voltages_v4s10_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_voltages_v4s10_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_voltages_v4s10_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_cell_voltages_v10s10_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_voltages_v10s10_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_voltages_v10s10_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_cell_voltages_v4s11_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_voltages_v4s11_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_voltages_v4s11_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_cell_voltages_v10s11_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_voltages_v10s11_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_voltages_v10s11_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_cell_voltages_v4s12_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_voltages_v4s12_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_voltages_v4s12_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_cell_voltages_v10s12_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_voltages_v10s12_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_voltages_v10s12_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_cell_voltages_v5s1_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_voltages_v5s1_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_voltages_v5s1_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_cell_voltages_v11s1_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_voltages_v11s1_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_voltages_v11s1_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_cell_voltages_v5s2_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_voltages_v5s2_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_voltages_v5s2_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_cell_voltages_v5s3_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_voltages_v5s3_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_voltages_v5s3_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_cell_voltages_v11s3_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_voltages_v11s3_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_voltages_v11s3_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_cell_voltages_v5s4_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_voltages_v5s4_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_voltages_v5s4_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_cell_voltages_v5s5_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_voltages_v5s5_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_voltages_v5s5_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_cell_voltages_v11s5_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_voltages_v11s5_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_voltages_v11s5_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_cell_voltages_v5s6_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_voltages_v5s6_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_voltages_v5s6_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_cell_voltages_v5s7_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_voltages_v5s7_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_voltages_v5s7_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_cell_voltages_v11s7_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_voltages_v11s7_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_voltages_v11s7_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_cell_voltages_v5s8_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_voltages_v5s8_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_voltages_v5s8_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_cell_voltages_v5s9_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_voltages_v5s9_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_voltages_v5s9_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_cell_voltages_v11s9_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_voltages_v11s9_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_voltages_v11s9_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_cell_voltages_v5s10_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_voltages_v5s10_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_voltages_v5s10_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_cell_voltages_v5s11_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_voltages_v5s11_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_voltages_v5s11_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_cell_voltages_v11s11_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_voltages_v11s11_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_voltages_v11s11_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_cell_voltages_v5s12_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_voltages_v5s12_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_voltages_v5s12_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_cell_voltages_v6s1_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_voltages_v6s1_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_voltages_v6s1_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_cell_voltages_v6s2_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_voltages_v6s2_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_voltages_v6s2_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_cell_voltages_v6s3_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_voltages_v6s3_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_voltages_v6s3_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_cell_voltages_v6s4_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_voltages_v6s4_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_voltages_v6s4_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_cell_voltages_v6s5_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_voltages_v6s5_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_voltages_v6s5_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_cell_voltages_v6s6_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_voltages_v6s6_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_voltages_v6s6_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_cell_voltages_v6s7_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_voltages_v6s7_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_voltages_v6s7_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_cell_voltages_v6s8_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_voltages_v6s8_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_voltages_v6s8_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_cell_voltages_v6s9_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_voltages_v6s9_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_voltages_v6s9_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_cell_voltages_v6s10_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_voltages_v6s10_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_voltages_v6s10_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_cell_voltages_v6s11_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_voltages_v6s11_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_voltages_v6s11_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_cell_voltages_v6s12_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_voltages_v6s12_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_voltages_v6s12_is_in_range(uint8_t value);

/**
 * Pack message ams_cell_temperatures.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can1_ams_cell_temperatures_pack(
    uint8_t *dst_p,
    const struct can1_ams_cell_temperatures_t *src_p,
    size_t size);

/**
 * Unpack message ams_cell_temperatures.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can1_ams_cell_temperatures_unpack(
    struct can1_ams_cell_temperatures_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_cell_temperatures_temperature_multiplexor_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_temperatures_temperature_multiplexor_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_temperatures_temperature_multiplexor_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_ams_cell_temperatures_t1s1_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_temperatures_t1s1_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_temperatures_t1s1_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_ams_cell_temperatures_t1s2_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_temperatures_t1s2_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_temperatures_t1s2_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_ams_cell_temperatures_t1s3_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_temperatures_t1s3_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_temperatures_t1s3_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_ams_cell_temperatures_t1s4_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_temperatures_t1s4_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_temperatures_t1s4_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_ams_cell_temperatures_t1s5_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_temperatures_t1s5_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_temperatures_t1s5_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_ams_cell_temperatures_t1s6_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_temperatures_t1s6_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_temperatures_t1s6_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_ams_cell_temperatures_t1s7_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_temperatures_t1s7_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_temperatures_t1s7_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_ams_cell_temperatures_t1s8_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_temperatures_t1s8_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_temperatures_t1s8_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_ams_cell_temperatures_t1s9_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_temperatures_t1s9_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_temperatures_t1s9_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_ams_cell_temperatures_t1s10_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_temperatures_t1s10_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_temperatures_t1s10_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_ams_cell_temperatures_t1s11_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_temperatures_t1s11_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_temperatures_t1s11_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_ams_cell_temperatures_t1s12_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_temperatures_t1s12_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_temperatures_t1s12_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_ams_cell_temperatures_t2s1_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_temperatures_t2s1_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_temperatures_t2s1_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_ams_cell_temperatures_t2s2_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_temperatures_t2s2_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_temperatures_t2s2_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_ams_cell_temperatures_t2s3_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_temperatures_t2s3_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_temperatures_t2s3_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_ams_cell_temperatures_t2s4_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_temperatures_t2s4_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_temperatures_t2s4_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_ams_cell_temperatures_t2s5_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_temperatures_t2s5_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_temperatures_t2s5_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_ams_cell_temperatures_t2s6_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_temperatures_t2s6_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_temperatures_t2s6_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_ams_cell_temperatures_t2s7_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_temperatures_t2s7_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_temperatures_t2s7_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_ams_cell_temperatures_t2s8_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_temperatures_t2s8_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_temperatures_t2s8_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_ams_cell_temperatures_t2s9_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_temperatures_t2s9_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_temperatures_t2s9_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_ams_cell_temperatures_t2s10_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_temperatures_t2s10_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_temperatures_t2s10_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_ams_cell_temperatures_t2s11_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_temperatures_t2s11_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_temperatures_t2s11_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_ams_cell_temperatures_t2s12_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_temperatures_t2s12_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_temperatures_t2s12_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_ams_cell_temperatures_t3s1_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_temperatures_t3s1_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_temperatures_t3s1_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_ams_cell_temperatures_t3s2_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_temperatures_t3s2_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_temperatures_t3s2_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_ams_cell_temperatures_t3s3_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_temperatures_t3s3_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_temperatures_t3s3_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_ams_cell_temperatures_t3s4_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_temperatures_t3s4_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_temperatures_t3s4_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_ams_cell_temperatures_t3s5_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_temperatures_t3s5_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_temperatures_t3s5_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_ams_cell_temperatures_t3s6_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_temperatures_t3s6_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_temperatures_t3s6_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_ams_cell_temperatures_t3s7_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_temperatures_t3s7_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_temperatures_t3s7_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_ams_cell_temperatures_t3s8_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_temperatures_t3s8_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_temperatures_t3s8_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_ams_cell_temperatures_t3s9_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_temperatures_t3s9_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_temperatures_t3s9_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_ams_cell_temperatures_t3s10_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_temperatures_t3s10_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_temperatures_t3s10_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_ams_cell_temperatures_t3s11_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_temperatures_t3s11_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_temperatures_t3s11_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_ams_cell_temperatures_t3s12_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_temperatures_t3s12_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_temperatures_t3s12_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_ams_cell_temperatures_t4s1_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_temperatures_t4s1_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_temperatures_t4s1_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_ams_cell_temperatures_t4s2_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_temperatures_t4s2_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_temperatures_t4s2_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_ams_cell_temperatures_t4s3_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_temperatures_t4s3_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_temperatures_t4s3_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_ams_cell_temperatures_t4s4_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_temperatures_t4s4_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_temperatures_t4s4_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_ams_cell_temperatures_t4s5_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_temperatures_t4s5_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_temperatures_t4s5_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_ams_cell_temperatures_t4s6_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_temperatures_t4s6_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_temperatures_t4s6_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_ams_cell_temperatures_t4s7_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_temperatures_t4s7_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_temperatures_t4s7_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_ams_cell_temperatures_t4s8_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_temperatures_t4s8_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_temperatures_t4s8_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_ams_cell_temperatures_t4s9_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_temperatures_t4s9_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_temperatures_t4s9_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_ams_cell_temperatures_t4s10_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_temperatures_t4s10_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_temperatures_t4s10_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_ams_cell_temperatures_t4s11_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_temperatures_t4s11_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_temperatures_t4s11_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_ams_cell_temperatures_t4s12_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_temperatures_t4s12_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_temperatures_t4s12_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_ams_cell_temperatures_t5s1_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_temperatures_t5s1_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_temperatures_t5s1_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_ams_cell_temperatures_t5s2_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_temperatures_t5s2_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_temperatures_t5s2_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_ams_cell_temperatures_t5s3_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_temperatures_t5s3_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_temperatures_t5s3_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_ams_cell_temperatures_t5s4_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_temperatures_t5s4_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_temperatures_t5s4_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_ams_cell_temperatures_t5s5_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_temperatures_t5s5_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_temperatures_t5s5_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_ams_cell_temperatures_t5s6_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_temperatures_t5s6_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_temperatures_t5s6_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_ams_cell_temperatures_t5s7_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_temperatures_t5s7_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_temperatures_t5s7_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_ams_cell_temperatures_t5s8_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_temperatures_t5s8_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_temperatures_t5s8_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_ams_cell_temperatures_t5s9_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_temperatures_t5s9_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_temperatures_t5s9_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_ams_cell_temperatures_t5s10_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_temperatures_t5s10_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_temperatures_t5s10_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_ams_cell_temperatures_t5s11_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_temperatures_t5s11_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_temperatures_t5s11_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_ams_cell_temperatures_t5s12_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_temperatures_t5s12_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_temperatures_t5s12_is_in_range(int16_t value);

/**
 * Pack message ecu_status.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can1_ecu_status_pack(
    uint8_t *dst_p,
    const struct can1_ecu_status_t *src_p,
    size_t size);

/**
 * Unpack message ecu_status.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can1_ecu_status_unpack(
    struct can1_ecu_status_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ecu_status_ts_not_off_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ecu_status_ts_not_off_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ecu_status_ts_not_off_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ecu_status_rst_button_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ecu_status_rst_button_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ecu_status_rst_button_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ecu_status_close_airs_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ecu_status_close_airs_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ecu_status_close_airs_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ecu_status_ts_off_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ecu_status_ts_off_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ecu_status_ts_off_is_in_range(uint8_t value);

/**
 * Pack message ebs_status.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can1_ebs_status_pack(
    uint8_t *dst_p,
    const struct can1_ebs_status_t *src_p,
    size_t size);

/**
 * Unpack message ebs_status.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can1_ebs_status_unpack(
    struct can1_ebs_status_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ebs_status_sc_tsms_status_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ebs_status_sc_tsms_status_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ebs_status_sc_tsms_status_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ebs_status_res_open_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ebs_status_res_open_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ebs_status_res_open_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ebs_status_ebs_status_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ebs_status_ebs_status_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ebs_status_ebs_status_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ebs_status_ebs_state_machine_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ebs_status_ebs_state_machine_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ebs_status_ebs_state_machine_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can1_ebs_status_ebs_pressure_1_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ebs_status_ebs_pressure_1_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ebs_status_ebs_pressure_1_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can1_ebs_status_ebs_pressure_2_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ebs_status_ebs_pressure_2_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ebs_status_ebs_pressure_2_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ebs_status_ebs_error_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ebs_status_ebs_error_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ebs_status_ebs_error_is_in_range(uint8_t value);

/**
 * Pack message dcu_pps.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can1_dcu_pps_pack(
    uint8_t *dst_p,
    const struct can1_dcu_pps_t *src_p,
    size_t size);

/**
 * Unpack message dcu_pps.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can1_dcu_pps_unpack(
    struct can1_dcu_pps_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can1_dcu_pps_apps_1_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_dcu_pps_apps_1_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_dcu_pps_apps_1_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can1_dcu_pps_apps_2_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_dcu_pps_apps_2_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_dcu_pps_apps_2_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can1_dcu_pps_bpps_1_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_dcu_pps_bpps_1_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_dcu_pps_bpps_1_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can1_dcu_pps_bpps_2_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_dcu_pps_bpps_2_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_dcu_pps_bpps_2_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can1_dcu_pps_acceleration_pedal_angle_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_dcu_pps_acceleration_pedal_angle_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_dcu_pps_acceleration_pedal_angle_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_dcu_pps_brake_pedal_angle_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_dcu_pps_brake_pedal_angle_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_dcu_pps_brake_pedal_angle_is_in_range(uint8_t value);

/**
 * Pack message dcu_status.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can1_dcu_status_pack(
    uint8_t *dst_p,
    const struct can1_dcu_status_t *src_p,
    size_t size);

/**
 * Unpack message dcu_status.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can1_dcu_status_unpack(
    struct can1_dcu_status_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can1_dcu_status_normalized_brake_pedal_travel_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_dcu_status_normalized_brake_pedal_travel_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_dcu_status_normalized_brake_pedal_travel_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can1_dcu_status_normalized_accelerator_pedal_travel_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_dcu_status_normalized_accelerator_pedal_travel_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_dcu_status_normalized_accelerator_pedal_travel_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_dcu_status_normalized_steering_wheel_angle_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_dcu_status_normalized_steering_wheel_angle_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_dcu_status_normalized_steering_wheel_angle_is_in_range(int16_t value);

/**
 * Pack message mcu_set_ccu_cooling_points.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can1_mcu_set_ccu_cooling_points_pack(
    uint8_t *dst_p,
    const struct can1_mcu_set_ccu_cooling_points_t *src_p,
    size_t size);

/**
 * Unpack message mcu_set_ccu_cooling_points.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can1_mcu_set_ccu_cooling_points_unpack(
    struct can1_mcu_set_ccu_cooling_points_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_mcu_set_ccu_cooling_points_mux_id_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_mcu_set_ccu_cooling_points_mux_id_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_mcu_set_ccu_cooling_points_mux_id_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_mcu_set_ccu_cooling_points_fan1_speed_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_mcu_set_ccu_cooling_points_fan1_speed_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_mcu_set_ccu_cooling_points_fan1_speed_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_mcu_set_ccu_cooling_points_fan2_speed_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_mcu_set_ccu_cooling_points_fan2_speed_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_mcu_set_ccu_cooling_points_fan2_speed_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_mcu_set_ccu_cooling_points_fan3_speed_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_mcu_set_ccu_cooling_points_fan3_speed_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_mcu_set_ccu_cooling_points_fan3_speed_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_mcu_set_ccu_cooling_points_fron_pump_speed_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_mcu_set_ccu_cooling_points_fron_pump_speed_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_mcu_set_ccu_cooling_points_fron_pump_speed_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_mcu_set_ccu_cooling_points_rear_pump_speed_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_mcu_set_ccu_cooling_points_rear_pump_speed_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_mcu_set_ccu_cooling_points_rear_pump_speed_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_mcu_set_ccu_cooling_points_inverter_pump_speed_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_mcu_set_ccu_cooling_points_inverter_pump_speed_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_mcu_set_ccu_cooling_points_inverter_pump_speed_is_in_range(uint8_t value);

/**
 * Pack message ccu_status_1.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can1_ccu_status_1_pack(
    uint8_t *dst_p,
    const struct can1_ccu_status_1_t *src_p,
    size_t size);

/**
 * Unpack message ccu_status_1.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can1_ccu_status_1_unpack(
    struct can1_ccu_status_1_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ccu_status_1_mux_id_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ccu_status_1_mux_id_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ccu_status_1_mux_id_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ccu_status_1_fan1_temperature_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ccu_status_1_fan1_temperature_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ccu_status_1_fan1_temperature_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ccu_status_1_fan2_temperature_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ccu_status_1_fan2_temperature_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ccu_status_1_fan2_temperature_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ccu_status_1_fan3_temperature_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ccu_status_1_fan3_temperature_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ccu_status_1_fan3_temperature_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ccu_status_1_fron_pump_temperature_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ccu_status_1_fron_pump_temperature_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ccu_status_1_fron_pump_temperature_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ccu_status_1_rear_pump_temperature_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ccu_status_1_rear_pump_temperature_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ccu_status_1_rear_pump_temperature_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ccu_status_1_inverter_pump_temperature_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ccu_status_1_inverter_pump_temperature_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ccu_status_1_inverter_pump_temperature_is_in_range(uint8_t value);

/**
 * Pack message ccu_status_2.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can1_ccu_status_2_pack(
    uint8_t *dst_p,
    const struct can1_ccu_status_2_t *src_p,
    size_t size);

/**
 * Unpack message ccu_status_2.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can1_ccu_status_2_unpack(
    struct can1_ccu_status_2_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ccu_status_2_digital_input_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ccu_status_2_digital_input_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ccu_status_2_digital_input_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ccu_status_2_discharge_relay_open_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ccu_status_2_discharge_relay_open_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ccu_status_2_discharge_relay_open_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can1_ccu_status_2_discharge_resistor_temperature_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ccu_status_2_discharge_resistor_temperature_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ccu_status_2_discharge_resistor_temperature_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can1_ccu_status_2_extra_temperature_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ccu_status_2_extra_temperature_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ccu_status_2_extra_temperature_is_in_range(uint16_t value);

/**
 * Pack message vehicle_status.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can1_vehicle_status_pack(
    uint8_t *dst_p,
    const struct can1_vehicle_status_t *src_p,
    size_t size);

/**
 * Unpack message vehicle_status.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can1_vehicle_status_unpack(
    struct can1_vehicle_status_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_vehicle_status_car_state_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_vehicle_status_car_state_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_vehicle_status_car_state_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_vehicle_status_car_velocity_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_vehicle_status_car_velocity_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_vehicle_status_car_velocity_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can1_vehicle_status_car_power_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_vehicle_status_car_power_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_vehicle_status_car_power_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_vehicle_status_car_regen_level_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_vehicle_status_car_regen_level_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_vehicle_status_car_regen_level_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_vehicle_status_ready_to_drive_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_vehicle_status_ready_to_drive_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_vehicle_status_ready_to_drive_is_in_range(uint8_t value);

/**
 * Pack message fault.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can1_fault_pack(
    uint8_t *dst_p,
    const struct can1_fault_t *src_p,
    size_t size);

/**
 * Unpack message fault.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can1_fault_unpack(
    struct can1_fault_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_fault_unit_id_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_fault_unit_id_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_fault_unit_id_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_fault_apps_discrepancy_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_fault_apps_discrepancy_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_fault_apps_discrepancy_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_fault_sc_open_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_fault_sc_open_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_fault_sc_open_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_fault_ts_off_watchdog_triggered_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_fault_ts_off_watchdog_triggered_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_fault_ts_off_watchdog_triggered_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_fault_bpps_discrepancy_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_fault_bpps_discrepancy_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_fault_bpps_discrepancy_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_fault_brake_pressure_discrepancy_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_fault_brake_pressure_discrepancy_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_fault_brake_pressure_discrepancy_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_fault_steering_angle_discrepancy_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_fault_steering_angle_discrepancy_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_fault_steering_angle_discrepancy_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_fault_apps_out_of_range_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_fault_apps_out_of_range_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_fault_apps_out_of_range_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_fault_bpps_out_of_range_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_fault_bpps_out_of_range_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_fault_bpps_out_of_range_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_fault_brake_pressure_out_of_range_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_fault_brake_pressure_out_of_range_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_fault_brake_pressure_out_of_range_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_fault_steering_angle_out_of_range_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_fault_steering_angle_out_of_range_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_fault_steering_angle_out_of_range_is_in_range(uint8_t value);

/**
 * Pack message dcu_status_steering_brake.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can1_dcu_status_steering_brake_pack(
    uint8_t *dst_p,
    const struct can1_dcu_status_steering_brake_t *src_p,
    size_t size);

/**
 * Unpack message dcu_status_steering_brake.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can1_dcu_status_steering_brake_unpack(
    struct can1_dcu_status_steering_brake_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_dcu_status_steering_brake_bspd_triggered_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_dcu_status_steering_brake_bspd_triggered_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_dcu_status_steering_brake_bspd_triggered_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can1_dcu_status_steering_brake_dcu_temperature_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_dcu_status_steering_brake_dcu_temperature_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_dcu_status_steering_brake_dcu_temperature_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_dcu_status_steering_brake_steering_angle_1_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_dcu_status_steering_brake_steering_angle_1_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_dcu_status_steering_brake_steering_angle_1_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_dcu_status_steering_brake_steering_angle_2_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_dcu_status_steering_brake_steering_angle_2_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_dcu_status_steering_brake_steering_angle_2_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can1_dcu_status_steering_brake_brake_pressure_1_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_dcu_status_steering_brake_brake_pressure_1_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_dcu_status_steering_brake_brake_pressure_1_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can1_dcu_status_steering_brake_brake_pressure_2_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_dcu_status_steering_brake_brake_pressure_2_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_dcu_status_steering_brake_brake_pressure_2_is_in_range(uint16_t value);

/**
 * Pack message dbu_status_2.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can1_dbu_status_2_pack(
    uint8_t *dst_p,
    const struct can1_dbu_status_2_t *src_p,
    size_t size);

/**
 * Unpack message dbu_status_2.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can1_dbu_status_2_unpack(
    struct can1_dbu_status_2_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_dbu_status_2_screen_id_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_dbu_status_2_screen_id_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_dbu_status_2_screen_id_is_in_range(uint8_t value);

/**
 * Pack message dv_control_target.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can1_dv_control_target_pack(
    uint8_t *dst_p,
    const struct can1_dv_control_target_t *src_p,
    size_t size);

/**
 * Unpack message dv_control_target.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can1_dv_control_target_unpack(
    struct can1_dv_control_target_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can1_dv_control_target_dv_speed_target_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_dv_control_target_dv_speed_target_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_dv_control_target_dv_speed_target_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_dv_control_target_dv_steering_angle_target_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_dv_control_target_dv_steering_angle_target_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_dv_control_target_dv_steering_angle_target_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_dv_control_target_dv_brake_hydralic_target_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_dv_control_target_dv_brake_hydralic_target_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_dv_control_target_dv_brake_hydralic_target_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_dv_control_target_dv_motor_moment_target_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_dv_control_target_dv_motor_moment_target_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_dv_control_target_dv_motor_moment_target_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_dv_control_target_dv_mission_status_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_dv_control_target_dv_mission_status_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_dv_control_target_dv_mission_status_is_in_range(uint8_t value);

/**
 * Pack message vehicle_status_wheel_speed.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can1_vehicle_status_wheel_speed_pack(
    uint8_t *dst_p,
    const struct can1_vehicle_status_wheel_speed_t *src_p,
    size_t size);

/**
 * Unpack message vehicle_status_wheel_speed.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can1_vehicle_status_wheel_speed_unpack(
    struct can1_vehicle_status_wheel_speed_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_vehicle_status_wheel_speed_wheel_speed_fl_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_vehicle_status_wheel_speed_wheel_speed_fl_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_vehicle_status_wheel_speed_wheel_speed_fl_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_vehicle_status_wheel_speed_wheel_speed_fr_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_vehicle_status_wheel_speed_wheel_speed_fr_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_vehicle_status_wheel_speed_wheel_speed_fr_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_vehicle_status_wheel_speed_wheel_speed_rl_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_vehicle_status_wheel_speed_wheel_speed_rl_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_vehicle_status_wheel_speed_wheel_speed_rl_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_vehicle_status_wheel_speed_wheel_speed_rr_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_vehicle_status_wheel_speed_wheel_speed_rr_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_vehicle_status_wheel_speed_wheel_speed_rr_is_in_range(int16_t value);

/**
 * Pack message SBG_ECAN_MSG_GPS2_HDT.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can1_sbg_ecan_msg_gps2_hdt_pack(
    uint8_t *dst_p,
    const struct can1_sbg_ecan_msg_gps2_hdt_t *src_p,
    size_t size);

/**
 * Unpack message SBG_ECAN_MSG_GPS2_HDT.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can1_sbg_ecan_msg_gps2_hdt_unpack(
    struct can1_sbg_ecan_msg_gps2_hdt_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can1_sbg_ecan_msg_gps2_hdt_true_heading_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_sbg_ecan_msg_gps2_hdt_true_heading_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_sbg_ecan_msg_gps2_hdt_true_heading_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can1_sbg_ecan_msg_gps2_hdt_true_heading_acc_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_sbg_ecan_msg_gps2_hdt_true_heading_acc_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_sbg_ecan_msg_gps2_hdt_true_heading_acc_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_sbg_ecan_msg_gps2_hdt_pitch_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_sbg_ecan_msg_gps2_hdt_pitch_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_sbg_ecan_msg_gps2_hdt_pitch_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can1_sbg_ecan_msg_gps2_hdt_pitch_acc_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_sbg_ecan_msg_gps2_hdt_pitch_acc_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_sbg_ecan_msg_gps2_hdt_pitch_acc_is_in_range(uint16_t value);

/**
 * Pack message SBG_ECAN_MSG_GPS2_HDT_INFO.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can1_sbg_ecan_msg_gps2_hdt_info_pack(
    uint8_t *dst_p,
    const struct can1_sbg_ecan_msg_gps2_hdt_info_t *src_p,
    size_t size);

/**
 * Unpack message SBG_ECAN_MSG_GPS2_HDT_INFO.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can1_sbg_ecan_msg_gps2_hdt_info_unpack(
    struct can1_sbg_ecan_msg_gps2_hdt_info_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t can1_sbg_ecan_msg_gps2_hdt_info_time_stamp_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_sbg_ecan_msg_gps2_hdt_info_time_stamp_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_sbg_ecan_msg_gps2_hdt_info_time_stamp_is_in_range(uint32_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can1_sbg_ecan_msg_gps2_hdt_info_status_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_sbg_ecan_msg_gps2_hdt_info_status_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_sbg_ecan_msg_gps2_hdt_info_status_is_in_range(uint16_t value);

/**
 * Pack message SBG_ECAN_MSG_GPS2_POS_ACC.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can1_sbg_ecan_msg_gps2_pos_acc_pack(
    uint8_t *dst_p,
    const struct can1_sbg_ecan_msg_gps2_pos_acc_t *src_p,
    size_t size);

/**
 * Unpack message SBG_ECAN_MSG_GPS2_POS_ACC.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can1_sbg_ecan_msg_gps2_pos_acc_unpack(
    struct can1_sbg_ecan_msg_gps2_pos_acc_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can1_sbg_ecan_msg_gps2_pos_acc_latitude_acc_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_sbg_ecan_msg_gps2_pos_acc_latitude_acc_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_sbg_ecan_msg_gps2_pos_acc_latitude_acc_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can1_sbg_ecan_msg_gps2_pos_acc_longitude_acc_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_sbg_ecan_msg_gps2_pos_acc_longitude_acc_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_sbg_ecan_msg_gps2_pos_acc_longitude_acc_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can1_sbg_ecan_msg_gps2_pos_acc_altitude_acc_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_sbg_ecan_msg_gps2_pos_acc_altitude_acc_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_sbg_ecan_msg_gps2_pos_acc_altitude_acc_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can1_sbg_ecan_msg_gps2_pos_acc_base_station_id_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_sbg_ecan_msg_gps2_pos_acc_base_station_id_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_sbg_ecan_msg_gps2_pos_acc_base_station_id_is_in_range(uint16_t value);

/**
 * Pack message SBG_ECAN_MSG_GPS2_POS_ALT.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can1_sbg_ecan_msg_gps2_pos_alt_pack(
    uint8_t *dst_p,
    const struct can1_sbg_ecan_msg_gps2_pos_alt_t *src_p,
    size_t size);

/**
 * Unpack message SBG_ECAN_MSG_GPS2_POS_ALT.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can1_sbg_ecan_msg_gps2_pos_alt_unpack(
    struct can1_sbg_ecan_msg_gps2_pos_alt_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int32_t can1_sbg_ecan_msg_gps2_pos_alt_altitude_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_sbg_ecan_msg_gps2_pos_alt_altitude_decode(int32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_sbg_ecan_msg_gps2_pos_alt_altitude_is_in_range(int32_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_sbg_ecan_msg_gps2_pos_alt_undulation_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_sbg_ecan_msg_gps2_pos_alt_undulation_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_sbg_ecan_msg_gps2_pos_alt_undulation_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_sbg_ecan_msg_gps2_pos_alt_num_sv_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_sbg_ecan_msg_gps2_pos_alt_num_sv_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_sbg_ecan_msg_gps2_pos_alt_num_sv_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_sbg_ecan_msg_gps2_pos_alt_diff_corr_age_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_sbg_ecan_msg_gps2_pos_alt_diff_corr_age_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_sbg_ecan_msg_gps2_pos_alt_diff_corr_age_is_in_range(uint8_t value);

/**
 * Pack message SBG_ECAN_MSG_GPS2_POS.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can1_sbg_ecan_msg_gps2_pos_pack(
    uint8_t *dst_p,
    const struct can1_sbg_ecan_msg_gps2_pos_t *src_p,
    size_t size);

/**
 * Unpack message SBG_ECAN_MSG_GPS2_POS.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can1_sbg_ecan_msg_gps2_pos_unpack(
    struct can1_sbg_ecan_msg_gps2_pos_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int32_t can1_sbg_ecan_msg_gps2_pos_latitude_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_sbg_ecan_msg_gps2_pos_latitude_decode(int32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_sbg_ecan_msg_gps2_pos_latitude_is_in_range(int32_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int32_t can1_sbg_ecan_msg_gps2_pos_longitude_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_sbg_ecan_msg_gps2_pos_longitude_decode(int32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_sbg_ecan_msg_gps2_pos_longitude_is_in_range(int32_t value);

/**
 * Pack message SBG_ECAN_MSG_GPS2_POS_INFO.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can1_sbg_ecan_msg_gps2_pos_info_pack(
    uint8_t *dst_p,
    const struct can1_sbg_ecan_msg_gps2_pos_info_t *src_p,
    size_t size);

/**
 * Unpack message SBG_ECAN_MSG_GPS2_POS_INFO.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can1_sbg_ecan_msg_gps2_pos_info_unpack(
    struct can1_sbg_ecan_msg_gps2_pos_info_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t can1_sbg_ecan_msg_gps2_pos_info_time_stamp_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_sbg_ecan_msg_gps2_pos_info_time_stamp_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_sbg_ecan_msg_gps2_pos_info_time_stamp_is_in_range(uint32_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t can1_sbg_ecan_msg_gps2_pos_info_status_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_sbg_ecan_msg_gps2_pos_info_status_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_sbg_ecan_msg_gps2_pos_info_status_is_in_range(uint32_t value);

/**
 * Pack message SBG_ECAN_MSG_GPS2_VEL_COURSE.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can1_sbg_ecan_msg_gps2_vel_course_pack(
    uint8_t *dst_p,
    const struct can1_sbg_ecan_msg_gps2_vel_course_t *src_p,
    size_t size);

/**
 * Unpack message SBG_ECAN_MSG_GPS2_VEL_COURSE.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can1_sbg_ecan_msg_gps2_vel_course_unpack(
    struct can1_sbg_ecan_msg_gps2_vel_course_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can1_sbg_ecan_msg_gps2_vel_course_course_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_sbg_ecan_msg_gps2_vel_course_course_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_sbg_ecan_msg_gps2_vel_course_course_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can1_sbg_ecan_msg_gps2_vel_course_course_acc_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_sbg_ecan_msg_gps2_vel_course_course_acc_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_sbg_ecan_msg_gps2_vel_course_course_acc_is_in_range(uint16_t value);

/**
 * Pack message SBG_ECAN_MSG_GPS2_VEL_ACC.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can1_sbg_ecan_msg_gps2_vel_acc_pack(
    uint8_t *dst_p,
    const struct can1_sbg_ecan_msg_gps2_vel_acc_t *src_p,
    size_t size);

/**
 * Unpack message SBG_ECAN_MSG_GPS2_VEL_ACC.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can1_sbg_ecan_msg_gps2_vel_acc_unpack(
    struct can1_sbg_ecan_msg_gps2_vel_acc_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_sbg_ecan_msg_gps2_vel_acc_velocity_acc_n_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_sbg_ecan_msg_gps2_vel_acc_velocity_acc_n_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_sbg_ecan_msg_gps2_vel_acc_velocity_acc_n_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_sbg_ecan_msg_gps2_vel_acc_velocity_acc_e_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_sbg_ecan_msg_gps2_vel_acc_velocity_acc_e_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_sbg_ecan_msg_gps2_vel_acc_velocity_acc_e_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_sbg_ecan_msg_gps2_vel_acc_velocity_acc_d_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_sbg_ecan_msg_gps2_vel_acc_velocity_acc_d_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_sbg_ecan_msg_gps2_vel_acc_velocity_acc_d_is_in_range(int16_t value);

/**
 * Pack message SBG_ECAN_MSG_GPS2_VEL.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can1_sbg_ecan_msg_gps2_vel_pack(
    uint8_t *dst_p,
    const struct can1_sbg_ecan_msg_gps2_vel_t *src_p,
    size_t size);

/**
 * Unpack message SBG_ECAN_MSG_GPS2_VEL.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can1_sbg_ecan_msg_gps2_vel_unpack(
    struct can1_sbg_ecan_msg_gps2_vel_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_sbg_ecan_msg_gps2_vel_velocity_n_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_sbg_ecan_msg_gps2_vel_velocity_n_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_sbg_ecan_msg_gps2_vel_velocity_n_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_sbg_ecan_msg_gps2_vel_velocity_e_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_sbg_ecan_msg_gps2_vel_velocity_e_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_sbg_ecan_msg_gps2_vel_velocity_e_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_sbg_ecan_msg_gps2_vel_velocity_d_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_sbg_ecan_msg_gps2_vel_velocity_d_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_sbg_ecan_msg_gps2_vel_velocity_d_is_in_range(int16_t value);

/**
 * Pack message SBG_ECAN_MSG_GPS2_VEL_INFO.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can1_sbg_ecan_msg_gps2_vel_info_pack(
    uint8_t *dst_p,
    const struct can1_sbg_ecan_msg_gps2_vel_info_t *src_p,
    size_t size);

/**
 * Unpack message SBG_ECAN_MSG_GPS2_VEL_INFO.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can1_sbg_ecan_msg_gps2_vel_info_unpack(
    struct can1_sbg_ecan_msg_gps2_vel_info_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t can1_sbg_ecan_msg_gps2_vel_info_time_stamp_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_sbg_ecan_msg_gps2_vel_info_time_stamp_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_sbg_ecan_msg_gps2_vel_info_time_stamp_is_in_range(uint32_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t can1_sbg_ecan_msg_gps2_vel_info_status_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_sbg_ecan_msg_gps2_vel_info_status_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_sbg_ecan_msg_gps2_vel_info_status_is_in_range(uint32_t value);

/**
 * Pack message SBG_ECAN_MSG_GPS1_HDT.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can1_sbg_ecan_msg_gps1_hdt_pack(
    uint8_t *dst_p,
    const struct can1_sbg_ecan_msg_gps1_hdt_t *src_p,
    size_t size);

/**
 * Unpack message SBG_ECAN_MSG_GPS1_HDT.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can1_sbg_ecan_msg_gps1_hdt_unpack(
    struct can1_sbg_ecan_msg_gps1_hdt_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can1_sbg_ecan_msg_gps1_hdt_true_heading_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_sbg_ecan_msg_gps1_hdt_true_heading_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_sbg_ecan_msg_gps1_hdt_true_heading_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can1_sbg_ecan_msg_gps1_hdt_true_heading_acc_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_sbg_ecan_msg_gps1_hdt_true_heading_acc_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_sbg_ecan_msg_gps1_hdt_true_heading_acc_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_sbg_ecan_msg_gps1_hdt_pitch_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_sbg_ecan_msg_gps1_hdt_pitch_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_sbg_ecan_msg_gps1_hdt_pitch_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can1_sbg_ecan_msg_gps1_hdt_pitch_acc_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_sbg_ecan_msg_gps1_hdt_pitch_acc_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_sbg_ecan_msg_gps1_hdt_pitch_acc_is_in_range(uint16_t value);

/**
 * Pack message SBG_ECAN_MSG_GPS1_HDT_INFO.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can1_sbg_ecan_msg_gps1_hdt_info_pack(
    uint8_t *dst_p,
    const struct can1_sbg_ecan_msg_gps1_hdt_info_t *src_p,
    size_t size);

/**
 * Unpack message SBG_ECAN_MSG_GPS1_HDT_INFO.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can1_sbg_ecan_msg_gps1_hdt_info_unpack(
    struct can1_sbg_ecan_msg_gps1_hdt_info_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t can1_sbg_ecan_msg_gps1_hdt_info_time_stamp_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_sbg_ecan_msg_gps1_hdt_info_time_stamp_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_sbg_ecan_msg_gps1_hdt_info_time_stamp_is_in_range(uint32_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can1_sbg_ecan_msg_gps1_hdt_info_status_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_sbg_ecan_msg_gps1_hdt_info_status_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_sbg_ecan_msg_gps1_hdt_info_status_is_in_range(uint16_t value);

/**
 * Pack message SBG_ECAN_MSG_GPS1_POS_ACC.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can1_sbg_ecan_msg_gps1_pos_acc_pack(
    uint8_t *dst_p,
    const struct can1_sbg_ecan_msg_gps1_pos_acc_t *src_p,
    size_t size);

/**
 * Unpack message SBG_ECAN_MSG_GPS1_POS_ACC.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can1_sbg_ecan_msg_gps1_pos_acc_unpack(
    struct can1_sbg_ecan_msg_gps1_pos_acc_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can1_sbg_ecan_msg_gps1_pos_acc_latitude_acc_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_sbg_ecan_msg_gps1_pos_acc_latitude_acc_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_sbg_ecan_msg_gps1_pos_acc_latitude_acc_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can1_sbg_ecan_msg_gps1_pos_acc_longitude_acc_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_sbg_ecan_msg_gps1_pos_acc_longitude_acc_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_sbg_ecan_msg_gps1_pos_acc_longitude_acc_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can1_sbg_ecan_msg_gps1_pos_acc_altitude_acc_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_sbg_ecan_msg_gps1_pos_acc_altitude_acc_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_sbg_ecan_msg_gps1_pos_acc_altitude_acc_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can1_sbg_ecan_msg_gps1_pos_acc_base_station_id_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_sbg_ecan_msg_gps1_pos_acc_base_station_id_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_sbg_ecan_msg_gps1_pos_acc_base_station_id_is_in_range(uint16_t value);

/**
 * Pack message SBG_ECAN_MSG_GPS1_POS_ALT.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can1_sbg_ecan_msg_gps1_pos_alt_pack(
    uint8_t *dst_p,
    const struct can1_sbg_ecan_msg_gps1_pos_alt_t *src_p,
    size_t size);

/**
 * Unpack message SBG_ECAN_MSG_GPS1_POS_ALT.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can1_sbg_ecan_msg_gps1_pos_alt_unpack(
    struct can1_sbg_ecan_msg_gps1_pos_alt_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int32_t can1_sbg_ecan_msg_gps1_pos_alt_altitude_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_sbg_ecan_msg_gps1_pos_alt_altitude_decode(int32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_sbg_ecan_msg_gps1_pos_alt_altitude_is_in_range(int32_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_sbg_ecan_msg_gps1_pos_alt_undulation_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_sbg_ecan_msg_gps1_pos_alt_undulation_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_sbg_ecan_msg_gps1_pos_alt_undulation_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_sbg_ecan_msg_gps1_pos_alt_num_sv_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_sbg_ecan_msg_gps1_pos_alt_num_sv_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_sbg_ecan_msg_gps1_pos_alt_num_sv_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_sbg_ecan_msg_gps1_pos_alt_diff_corr_age_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_sbg_ecan_msg_gps1_pos_alt_diff_corr_age_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_sbg_ecan_msg_gps1_pos_alt_diff_corr_age_is_in_range(uint8_t value);

/**
 * Pack message SBG_ECAN_MSG_GPS1_POS.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can1_sbg_ecan_msg_gps1_pos_pack(
    uint8_t *dst_p,
    const struct can1_sbg_ecan_msg_gps1_pos_t *src_p,
    size_t size);

/**
 * Unpack message SBG_ECAN_MSG_GPS1_POS.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can1_sbg_ecan_msg_gps1_pos_unpack(
    struct can1_sbg_ecan_msg_gps1_pos_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int32_t can1_sbg_ecan_msg_gps1_pos_latitude_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_sbg_ecan_msg_gps1_pos_latitude_decode(int32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_sbg_ecan_msg_gps1_pos_latitude_is_in_range(int32_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int32_t can1_sbg_ecan_msg_gps1_pos_longitude_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_sbg_ecan_msg_gps1_pos_longitude_decode(int32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_sbg_ecan_msg_gps1_pos_longitude_is_in_range(int32_t value);

/**
 * Pack message SBG_ECAN_MSG_GPS1_POS_INFO.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can1_sbg_ecan_msg_gps1_pos_info_pack(
    uint8_t *dst_p,
    const struct can1_sbg_ecan_msg_gps1_pos_info_t *src_p,
    size_t size);

/**
 * Unpack message SBG_ECAN_MSG_GPS1_POS_INFO.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can1_sbg_ecan_msg_gps1_pos_info_unpack(
    struct can1_sbg_ecan_msg_gps1_pos_info_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t can1_sbg_ecan_msg_gps1_pos_info_time_stamp_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_sbg_ecan_msg_gps1_pos_info_time_stamp_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_sbg_ecan_msg_gps1_pos_info_time_stamp_is_in_range(uint32_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t can1_sbg_ecan_msg_gps1_pos_info_status_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_sbg_ecan_msg_gps1_pos_info_status_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_sbg_ecan_msg_gps1_pos_info_status_is_in_range(uint32_t value);

/**
 * Pack message SBG_ECAN_MSG_GPS1_VEL_COURSE.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can1_sbg_ecan_msg_gps1_vel_course_pack(
    uint8_t *dst_p,
    const struct can1_sbg_ecan_msg_gps1_vel_course_t *src_p,
    size_t size);

/**
 * Unpack message SBG_ECAN_MSG_GPS1_VEL_COURSE.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can1_sbg_ecan_msg_gps1_vel_course_unpack(
    struct can1_sbg_ecan_msg_gps1_vel_course_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can1_sbg_ecan_msg_gps1_vel_course_course_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_sbg_ecan_msg_gps1_vel_course_course_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_sbg_ecan_msg_gps1_vel_course_course_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can1_sbg_ecan_msg_gps1_vel_course_course_acc_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_sbg_ecan_msg_gps1_vel_course_course_acc_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_sbg_ecan_msg_gps1_vel_course_course_acc_is_in_range(uint16_t value);

/**
 * Pack message SBG_ECAN_MSG_GPS1_VEL_ACC.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can1_sbg_ecan_msg_gps1_vel_acc_pack(
    uint8_t *dst_p,
    const struct can1_sbg_ecan_msg_gps1_vel_acc_t *src_p,
    size_t size);

/**
 * Unpack message SBG_ECAN_MSG_GPS1_VEL_ACC.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can1_sbg_ecan_msg_gps1_vel_acc_unpack(
    struct can1_sbg_ecan_msg_gps1_vel_acc_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_sbg_ecan_msg_gps1_vel_acc_velocity_acc_n_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_sbg_ecan_msg_gps1_vel_acc_velocity_acc_n_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_sbg_ecan_msg_gps1_vel_acc_velocity_acc_n_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_sbg_ecan_msg_gps1_vel_acc_velocity_acc_e_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_sbg_ecan_msg_gps1_vel_acc_velocity_acc_e_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_sbg_ecan_msg_gps1_vel_acc_velocity_acc_e_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_sbg_ecan_msg_gps1_vel_acc_velocity_acc_d_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_sbg_ecan_msg_gps1_vel_acc_velocity_acc_d_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_sbg_ecan_msg_gps1_vel_acc_velocity_acc_d_is_in_range(int16_t value);

/**
 * Pack message SBG_ECAN_MSG_GPS1_VEL.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can1_sbg_ecan_msg_gps1_vel_pack(
    uint8_t *dst_p,
    const struct can1_sbg_ecan_msg_gps1_vel_t *src_p,
    size_t size);

/**
 * Unpack message SBG_ECAN_MSG_GPS1_VEL.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can1_sbg_ecan_msg_gps1_vel_unpack(
    struct can1_sbg_ecan_msg_gps1_vel_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_sbg_ecan_msg_gps1_vel_velocity_n_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_sbg_ecan_msg_gps1_vel_velocity_n_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_sbg_ecan_msg_gps1_vel_velocity_n_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_sbg_ecan_msg_gps1_vel_velocity_e_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_sbg_ecan_msg_gps1_vel_velocity_e_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_sbg_ecan_msg_gps1_vel_velocity_e_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_sbg_ecan_msg_gps1_vel_velocity_d_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_sbg_ecan_msg_gps1_vel_velocity_d_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_sbg_ecan_msg_gps1_vel_velocity_d_is_in_range(int16_t value);

/**
 * Pack message SBG_ECAN_MSG_GPS1_VEL_INFO.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can1_sbg_ecan_msg_gps1_vel_info_pack(
    uint8_t *dst_p,
    const struct can1_sbg_ecan_msg_gps1_vel_info_t *src_p,
    size_t size);

/**
 * Unpack message SBG_ECAN_MSG_GPS1_VEL_INFO.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can1_sbg_ecan_msg_gps1_vel_info_unpack(
    struct can1_sbg_ecan_msg_gps1_vel_info_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t can1_sbg_ecan_msg_gps1_vel_info_time_stamp_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_sbg_ecan_msg_gps1_vel_info_time_stamp_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_sbg_ecan_msg_gps1_vel_info_time_stamp_is_in_range(uint32_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t can1_sbg_ecan_msg_gps1_vel_info_status_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_sbg_ecan_msg_gps1_vel_info_status_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_sbg_ecan_msg_gps1_vel_info_status_is_in_range(uint32_t value);

/**
 * Pack message SBG_ECAN_MSG_ODO_VEL.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can1_sbg_ecan_msg_odo_vel_pack(
    uint8_t *dst_p,
    const struct can1_sbg_ecan_msg_odo_vel_t *src_p,
    size_t size);

/**
 * Unpack message SBG_ECAN_MSG_ODO_VEL.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can1_sbg_ecan_msg_odo_vel_unpack(
    struct can1_sbg_ecan_msg_odo_vel_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_sbg_ecan_msg_odo_vel_velocity_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_sbg_ecan_msg_odo_vel_velocity_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_sbg_ecan_msg_odo_vel_velocity_is_in_range(int16_t value);

/**
 * Pack message SBG_ECAN_MSG_ODO_INFO.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can1_sbg_ecan_msg_odo_info_pack(
    uint8_t *dst_p,
    const struct can1_sbg_ecan_msg_odo_info_t *src_p,
    size_t size);

/**
 * Unpack message SBG_ECAN_MSG_ODO_INFO.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can1_sbg_ecan_msg_odo_info_unpack(
    struct can1_sbg_ecan_msg_odo_info_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t can1_sbg_ecan_msg_odo_info_time_stamp_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_sbg_ecan_msg_odo_info_time_stamp_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_sbg_ecan_msg_odo_info_time_stamp_is_in_range(uint32_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can1_sbg_ecan_msg_odo_info_odo_status_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_sbg_ecan_msg_odo_info_odo_status_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_sbg_ecan_msg_odo_info_odo_status_is_in_range(uint16_t value);

/**
 * Pack message SBG_ECAN_MSG_EKF_VEL_BODY.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can1_sbg_ecan_msg_ekf_vel_body_pack(
    uint8_t *dst_p,
    const struct can1_sbg_ecan_msg_ekf_vel_body_t *src_p,
    size_t size);

/**
 * Unpack message SBG_ECAN_MSG_EKF_VEL_BODY.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can1_sbg_ecan_msg_ekf_vel_body_unpack(
    struct can1_sbg_ecan_msg_ekf_vel_body_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_sbg_ecan_msg_ekf_vel_body_velocity_x_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_sbg_ecan_msg_ekf_vel_body_velocity_x_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_sbg_ecan_msg_ekf_vel_body_velocity_x_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_sbg_ecan_msg_ekf_vel_body_velocity_y_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_sbg_ecan_msg_ekf_vel_body_velocity_y_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_sbg_ecan_msg_ekf_vel_body_velocity_y_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_sbg_ecan_msg_ekf_vel_body_velocity_z_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_sbg_ecan_msg_ekf_vel_body_velocity_z_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_sbg_ecan_msg_ekf_vel_body_velocity_z_is_in_range(int16_t value);

/**
 * Pack message SBG_ECAN_MSG_EKF_VEL_NED_ACC.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can1_sbg_ecan_msg_ekf_vel_ned_acc_pack(
    uint8_t *dst_p,
    const struct can1_sbg_ecan_msg_ekf_vel_ned_acc_t *src_p,
    size_t size);

/**
 * Unpack message SBG_ECAN_MSG_EKF_VEL_NED_ACC.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can1_sbg_ecan_msg_ekf_vel_ned_acc_unpack(
    struct can1_sbg_ecan_msg_ekf_vel_ned_acc_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_sbg_ecan_msg_ekf_vel_ned_acc_velocity_acc_n_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_sbg_ecan_msg_ekf_vel_ned_acc_velocity_acc_n_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_sbg_ecan_msg_ekf_vel_ned_acc_velocity_acc_n_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_sbg_ecan_msg_ekf_vel_ned_acc_velocity_acc_e_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_sbg_ecan_msg_ekf_vel_ned_acc_velocity_acc_e_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_sbg_ecan_msg_ekf_vel_ned_acc_velocity_acc_e_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_sbg_ecan_msg_ekf_vel_ned_acc_velocity_acc_d_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_sbg_ecan_msg_ekf_vel_ned_acc_velocity_acc_d_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_sbg_ecan_msg_ekf_vel_ned_acc_velocity_acc_d_is_in_range(int16_t value);

/**
 * Pack message SBG_ECAN_MSG_EKF_VEL_NED.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can1_sbg_ecan_msg_ekf_vel_ned_pack(
    uint8_t *dst_p,
    const struct can1_sbg_ecan_msg_ekf_vel_ned_t *src_p,
    size_t size);

/**
 * Unpack message SBG_ECAN_MSG_EKF_VEL_NED.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can1_sbg_ecan_msg_ekf_vel_ned_unpack(
    struct can1_sbg_ecan_msg_ekf_vel_ned_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_sbg_ecan_msg_ekf_vel_ned_velocity_n_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_sbg_ecan_msg_ekf_vel_ned_velocity_n_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_sbg_ecan_msg_ekf_vel_ned_velocity_n_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_sbg_ecan_msg_ekf_vel_ned_velocity_e_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_sbg_ecan_msg_ekf_vel_ned_velocity_e_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_sbg_ecan_msg_ekf_vel_ned_velocity_e_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_sbg_ecan_msg_ekf_vel_ned_velocity_d_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_sbg_ecan_msg_ekf_vel_ned_velocity_d_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_sbg_ecan_msg_ekf_vel_ned_velocity_d_is_in_range(int16_t value);

/**
 * Pack message SBG_ECAN_MSG_EKF_POS_ACC.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can1_sbg_ecan_msg_ekf_pos_acc_pack(
    uint8_t *dst_p,
    const struct can1_sbg_ecan_msg_ekf_pos_acc_t *src_p,
    size_t size);

/**
 * Unpack message SBG_ECAN_MSG_EKF_POS_ACC.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can1_sbg_ecan_msg_ekf_pos_acc_unpack(
    struct can1_sbg_ecan_msg_ekf_pos_acc_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can1_sbg_ecan_msg_ekf_pos_acc_latitude_acc_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_sbg_ecan_msg_ekf_pos_acc_latitude_acc_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_sbg_ecan_msg_ekf_pos_acc_latitude_acc_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can1_sbg_ecan_msg_ekf_pos_acc_longitude_acc_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_sbg_ecan_msg_ekf_pos_acc_longitude_acc_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_sbg_ecan_msg_ekf_pos_acc_longitude_acc_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can1_sbg_ecan_msg_ekf_pos_acc_altitude_acc_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_sbg_ecan_msg_ekf_pos_acc_altitude_acc_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_sbg_ecan_msg_ekf_pos_acc_altitude_acc_is_in_range(uint16_t value);

/**
 * Pack message SBG_ECAN_MSG_EKF_POS.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can1_sbg_ecan_msg_ekf_pos_pack(
    uint8_t *dst_p,
    const struct can1_sbg_ecan_msg_ekf_pos_t *src_p,
    size_t size);

/**
 * Unpack message SBG_ECAN_MSG_EKF_POS.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can1_sbg_ecan_msg_ekf_pos_unpack(
    struct can1_sbg_ecan_msg_ekf_pos_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int32_t can1_sbg_ecan_msg_ekf_pos_latitude_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_sbg_ecan_msg_ekf_pos_latitude_decode(int32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_sbg_ecan_msg_ekf_pos_latitude_is_in_range(int32_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int32_t can1_sbg_ecan_msg_ekf_pos_longitude_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_sbg_ecan_msg_ekf_pos_longitude_decode(int32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_sbg_ecan_msg_ekf_pos_longitude_is_in_range(int32_t value);

/**
 * Pack message SBG_ECAN_MSG_EKF_ORIENTATION_ACC.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can1_sbg_ecan_msg_ekf_orientation_acc_pack(
    uint8_t *dst_p,
    const struct can1_sbg_ecan_msg_ekf_orientation_acc_t *src_p,
    size_t size);

/**
 * Unpack message SBG_ECAN_MSG_EKF_ORIENTATION_ACC.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can1_sbg_ecan_msg_ekf_orientation_acc_unpack(
    struct can1_sbg_ecan_msg_ekf_orientation_acc_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can1_sbg_ecan_msg_ekf_orientation_acc_roll_acc_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_sbg_ecan_msg_ekf_orientation_acc_roll_acc_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_sbg_ecan_msg_ekf_orientation_acc_roll_acc_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can1_sbg_ecan_msg_ekf_orientation_acc_pitch_acc_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_sbg_ecan_msg_ekf_orientation_acc_pitch_acc_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_sbg_ecan_msg_ekf_orientation_acc_pitch_acc_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can1_sbg_ecan_msg_ekf_orientation_acc_yaw_acc_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_sbg_ecan_msg_ekf_orientation_acc_yaw_acc_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_sbg_ecan_msg_ekf_orientation_acc_yaw_acc_is_in_range(uint16_t value);

/**
 * Pack message SBG_ECAN_MSG_EKF_EULER.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can1_sbg_ecan_msg_ekf_euler_pack(
    uint8_t *dst_p,
    const struct can1_sbg_ecan_msg_ekf_euler_t *src_p,
    size_t size);

/**
 * Unpack message SBG_ECAN_MSG_EKF_EULER.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can1_sbg_ecan_msg_ekf_euler_unpack(
    struct can1_sbg_ecan_msg_ekf_euler_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_sbg_ecan_msg_ekf_euler_roll_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_sbg_ecan_msg_ekf_euler_roll_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_sbg_ecan_msg_ekf_euler_roll_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_sbg_ecan_msg_ekf_euler_pitch_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_sbg_ecan_msg_ekf_euler_pitch_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_sbg_ecan_msg_ekf_euler_pitch_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_sbg_ecan_msg_ekf_euler_yaw_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_sbg_ecan_msg_ekf_euler_yaw_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_sbg_ecan_msg_ekf_euler_yaw_is_in_range(int16_t value);

/**
 * Pack message SBG_ECAN_MSG_EKF_QUAT.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can1_sbg_ecan_msg_ekf_quat_pack(
    uint8_t *dst_p,
    const struct can1_sbg_ecan_msg_ekf_quat_t *src_p,
    size_t size);

/**
 * Unpack message SBG_ECAN_MSG_EKF_QUAT.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can1_sbg_ecan_msg_ekf_quat_unpack(
    struct can1_sbg_ecan_msg_ekf_quat_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_sbg_ecan_msg_ekf_quat_q0_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_sbg_ecan_msg_ekf_quat_q0_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_sbg_ecan_msg_ekf_quat_q0_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_sbg_ecan_msg_ekf_quat_q1_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_sbg_ecan_msg_ekf_quat_q1_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_sbg_ecan_msg_ekf_quat_q1_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_sbg_ecan_msg_ekf_quat_q2_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_sbg_ecan_msg_ekf_quat_q2_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_sbg_ecan_msg_ekf_quat_q2_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_sbg_ecan_msg_ekf_quat_q3_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_sbg_ecan_msg_ekf_quat_q3_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_sbg_ecan_msg_ekf_quat_q3_is_in_range(int16_t value);

/**
 * Pack message SBG_ECAN_MSG_EKF_INFO.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can1_sbg_ecan_msg_ekf_info_pack(
    uint8_t *dst_p,
    const struct can1_sbg_ecan_msg_ekf_info_t *src_p,
    size_t size);

/**
 * Unpack message SBG_ECAN_MSG_EKF_INFO.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can1_sbg_ecan_msg_ekf_info_unpack(
    struct can1_sbg_ecan_msg_ekf_info_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t can1_sbg_ecan_msg_ekf_info_time_stamp_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_sbg_ecan_msg_ekf_info_time_stamp_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_sbg_ecan_msg_ekf_info_time_stamp_is_in_range(uint32_t value);

/**
 * Pack message SBG_ECAN_MSG_IMU_DELTA_ANGLE.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can1_sbg_ecan_msg_imu_delta_angle_pack(
    uint8_t *dst_p,
    const struct can1_sbg_ecan_msg_imu_delta_angle_t *src_p,
    size_t size);

/**
 * Unpack message SBG_ECAN_MSG_IMU_DELTA_ANGLE.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can1_sbg_ecan_msg_imu_delta_angle_unpack(
    struct can1_sbg_ecan_msg_imu_delta_angle_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_sbg_ecan_msg_imu_delta_angle_delta_angle_x_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_sbg_ecan_msg_imu_delta_angle_delta_angle_x_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_sbg_ecan_msg_imu_delta_angle_delta_angle_x_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_sbg_ecan_msg_imu_delta_angle_delta_angle_y_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_sbg_ecan_msg_imu_delta_angle_delta_angle_y_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_sbg_ecan_msg_imu_delta_angle_delta_angle_y_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_sbg_ecan_msg_imu_delta_angle_delta_angle_z_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_sbg_ecan_msg_imu_delta_angle_delta_angle_z_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_sbg_ecan_msg_imu_delta_angle_delta_angle_z_is_in_range(int16_t value);

/**
 * Pack message SBG_ECAN_MSG_IMU_DELTA_VEL.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can1_sbg_ecan_msg_imu_delta_vel_pack(
    uint8_t *dst_p,
    const struct can1_sbg_ecan_msg_imu_delta_vel_t *src_p,
    size_t size);

/**
 * Unpack message SBG_ECAN_MSG_IMU_DELTA_VEL.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can1_sbg_ecan_msg_imu_delta_vel_unpack(
    struct can1_sbg_ecan_msg_imu_delta_vel_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_sbg_ecan_msg_imu_delta_vel_delta_vel_x_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_sbg_ecan_msg_imu_delta_vel_delta_vel_x_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_sbg_ecan_msg_imu_delta_vel_delta_vel_x_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_sbg_ecan_msg_imu_delta_vel_delta_vel_y_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_sbg_ecan_msg_imu_delta_vel_delta_vel_y_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_sbg_ecan_msg_imu_delta_vel_delta_vel_y_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_sbg_ecan_msg_imu_delta_vel_delta_vel_z_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_sbg_ecan_msg_imu_delta_vel_delta_vel_z_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_sbg_ecan_msg_imu_delta_vel_delta_vel_z_is_in_range(int16_t value);

/**
 * Pack message SBG_ECAN_MSG_IMU_GYRO.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can1_sbg_ecan_msg_imu_gyro_pack(
    uint8_t *dst_p,
    const struct can1_sbg_ecan_msg_imu_gyro_t *src_p,
    size_t size);

/**
 * Unpack message SBG_ECAN_MSG_IMU_GYRO.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can1_sbg_ecan_msg_imu_gyro_unpack(
    struct can1_sbg_ecan_msg_imu_gyro_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_sbg_ecan_msg_imu_gyro_gyro_x_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_sbg_ecan_msg_imu_gyro_gyro_x_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_sbg_ecan_msg_imu_gyro_gyro_x_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_sbg_ecan_msg_imu_gyro_gyro_y_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_sbg_ecan_msg_imu_gyro_gyro_y_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_sbg_ecan_msg_imu_gyro_gyro_y_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_sbg_ecan_msg_imu_gyro_gyro_z_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_sbg_ecan_msg_imu_gyro_gyro_z_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_sbg_ecan_msg_imu_gyro_gyro_z_is_in_range(int16_t value);

/**
 * Pack message SBG_ECAN_MSG_IMU_ACCEL.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can1_sbg_ecan_msg_imu_accel_pack(
    uint8_t *dst_p,
    const struct can1_sbg_ecan_msg_imu_accel_t *src_p,
    size_t size);

/**
 * Unpack message SBG_ECAN_MSG_IMU_ACCEL.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can1_sbg_ecan_msg_imu_accel_unpack(
    struct can1_sbg_ecan_msg_imu_accel_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_sbg_ecan_msg_imu_accel_accel_x_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_sbg_ecan_msg_imu_accel_accel_x_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_sbg_ecan_msg_imu_accel_accel_x_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_sbg_ecan_msg_imu_accel_accel_y_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_sbg_ecan_msg_imu_accel_accel_y_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_sbg_ecan_msg_imu_accel_accel_y_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_sbg_ecan_msg_imu_accel_accel_z_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_sbg_ecan_msg_imu_accel_accel_z_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_sbg_ecan_msg_imu_accel_accel_z_is_in_range(int16_t value);

/**
 * Pack message SBG_ECAN_MSG_IMU_INFO.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can1_sbg_ecan_msg_imu_info_pack(
    uint8_t *dst_p,
    const struct can1_sbg_ecan_msg_imu_info_t *src_p,
    size_t size);

/**
 * Unpack message SBG_ECAN_MSG_IMU_INFO.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can1_sbg_ecan_msg_imu_info_unpack(
    struct can1_sbg_ecan_msg_imu_info_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t can1_sbg_ecan_msg_imu_info_time_stamp_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_sbg_ecan_msg_imu_info_time_stamp_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_sbg_ecan_msg_imu_info_time_stamp_is_in_range(uint32_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can1_sbg_ecan_msg_imu_info_status_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_sbg_ecan_msg_imu_info_status_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_sbg_ecan_msg_imu_info_status_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_sbg_ecan_msg_imu_info_temperature_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_sbg_ecan_msg_imu_info_temperature_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_sbg_ecan_msg_imu_info_temperature_is_in_range(int16_t value);

/**
 * Pack message SBG_ECAN_MSG_UTC_1.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can1_sbg_ecan_msg_utc_1_pack(
    uint8_t *dst_p,
    const struct can1_sbg_ecan_msg_utc_1_t *src_p,
    size_t size);

/**
 * Unpack message SBG_ECAN_MSG_UTC_1.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can1_sbg_ecan_msg_utc_1_unpack(
    struct can1_sbg_ecan_msg_utc_1_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_sbg_ecan_msg_utc_1_year_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_sbg_ecan_msg_utc_1_year_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_sbg_ecan_msg_utc_1_year_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_sbg_ecan_msg_utc_1_month_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_sbg_ecan_msg_utc_1_month_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_sbg_ecan_msg_utc_1_month_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_sbg_ecan_msg_utc_1_day_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_sbg_ecan_msg_utc_1_day_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_sbg_ecan_msg_utc_1_day_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_sbg_ecan_msg_utc_1_hour_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_sbg_ecan_msg_utc_1_hour_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_sbg_ecan_msg_utc_1_hour_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_sbg_ecan_msg_utc_1_min_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_sbg_ecan_msg_utc_1_min_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_sbg_ecan_msg_utc_1_min_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_sbg_ecan_msg_utc_1_sec_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_sbg_ecan_msg_utc_1_sec_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_sbg_ecan_msg_utc_1_sec_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can1_sbg_ecan_msg_utc_1_micro_sec_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_sbg_ecan_msg_utc_1_micro_sec_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_sbg_ecan_msg_utc_1_micro_sec_is_in_range(uint16_t value);

/**
 * Pack message SBG_ECAN_MSG_UTC_0.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can1_sbg_ecan_msg_utc_0_pack(
    uint8_t *dst_p,
    const struct can1_sbg_ecan_msg_utc_0_t *src_p,
    size_t size);

/**
 * Unpack message SBG_ECAN_MSG_UTC_0.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can1_sbg_ecan_msg_utc_0_unpack(
    struct can1_sbg_ecan_msg_utc_0_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t can1_sbg_ecan_msg_utc_0_time_stamp_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_sbg_ecan_msg_utc_0_time_stamp_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_sbg_ecan_msg_utc_0_time_stamp_is_in_range(uint32_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t can1_sbg_ecan_msg_utc_0_gps_tow_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_sbg_ecan_msg_utc_0_gps_tow_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_sbg_ecan_msg_utc_0_gps_tow_is_in_range(uint32_t value);

/**
 * Pack message FS_Datalogger_Reserved_6.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can1_fs_datalogger_reserved_6_pack(
    uint8_t *dst_p,
    const struct can1_fs_datalogger_reserved_6_t *src_p,
    size_t size);

/**
 * Unpack message FS_Datalogger_Reserved_6.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can1_fs_datalogger_reserved_6_unpack(
    struct can1_fs_datalogger_reserved_6_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Pack message FS_Datalogger_Reserved_5.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can1_fs_datalogger_reserved_5_pack(
    uint8_t *dst_p,
    const struct can1_fs_datalogger_reserved_5_t *src_p,
    size_t size);

/**
 * Unpack message FS_Datalogger_Reserved_5.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can1_fs_datalogger_reserved_5_unpack(
    struct can1_fs_datalogger_reserved_5_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Pack message FS_Datalogger_Reserved_4.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can1_fs_datalogger_reserved_4_pack(
    uint8_t *dst_p,
    const struct can1_fs_datalogger_reserved_4_t *src_p,
    size_t size);

/**
 * Unpack message FS_Datalogger_Reserved_4.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can1_fs_datalogger_reserved_4_unpack(
    struct can1_fs_datalogger_reserved_4_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Pack message FS_Datalogger_Reserved_3.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can1_fs_datalogger_reserved_3_pack(
    uint8_t *dst_p,
    const struct can1_fs_datalogger_reserved_3_t *src_p,
    size_t size);

/**
 * Unpack message FS_Datalogger_Reserved_3.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can1_fs_datalogger_reserved_3_unpack(
    struct can1_fs_datalogger_reserved_3_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Pack message FS_Datalogger_Reserved_2.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can1_fs_datalogger_reserved_2_pack(
    uint8_t *dst_p,
    const struct can1_fs_datalogger_reserved_2_t *src_p,
    size_t size);

/**
 * Unpack message FS_Datalogger_Reserved_2.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can1_fs_datalogger_reserved_2_unpack(
    struct can1_fs_datalogger_reserved_2_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Pack message FS_Datalogger_Reserved_1.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can1_fs_datalogger_reserved_1_pack(
    uint8_t *dst_p,
    const struct can1_fs_datalogger_reserved_1_t *src_p,
    size_t size);

/**
 * Unpack message FS_Datalogger_Reserved_1.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can1_fs_datalogger_reserved_1_unpack(
    struct can1_fs_datalogger_reserved_1_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Pack message FS_Datalogger_Status.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can1_fs_datalogger_status_pack(
    uint8_t *dst_p,
    const struct can1_fs_datalogger_status_t *src_p,
    size_t size);

/**
 * Unpack message FS_Datalogger_Status.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can1_fs_datalogger_status_unpack(
    struct can1_fs_datalogger_status_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_fs_datalogger_status_msg_cnt_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_fs_datalogger_status_msg_cnt_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_fs_datalogger_status_msg_cnt_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int8_t can1_fs_datalogger_status_status_ready_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_fs_datalogger_status_status_ready_decode(int8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_fs_datalogger_status_status_ready_is_in_range(int8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int8_t can1_fs_datalogger_status_status_logging_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_fs_datalogger_status_status_logging_decode(int8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_fs_datalogger_status_status_logging_is_in_range(int8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int8_t can1_fs_datalogger_status_status_triggered_voltage_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_fs_datalogger_status_status_triggered_voltage_decode(int8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_fs_datalogger_status_status_triggered_voltage_is_in_range(int8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int8_t can1_fs_datalogger_status_status_triggered_current_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_fs_datalogger_status_status_triggered_current_decode(int8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_fs_datalogger_status_status_triggered_current_is_in_range(int8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can1_fs_datalogger_status_voltage_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_fs_datalogger_status_voltage_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_fs_datalogger_status_voltage_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can1_fs_datalogger_status_current_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_fs_datalogger_status_current_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_fs_datalogger_status_current_is_in_range(uint16_t value);

/**
 * Pack message vesc_status_2.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can1_vesc_status_2_pack(
    uint8_t *dst_p,
    const struct can1_vesc_status_2_t *src_p,
    size_t size);

/**
 * Unpack message vesc_status_2.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can1_vesc_status_2_unpack(
    struct can1_vesc_status_2_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int32_t can1_vesc_status_2_amp_hours_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_vesc_status_2_amp_hours_decode(int32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_vesc_status_2_amp_hours_is_in_range(int32_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int32_t can1_vesc_status_2_amp_hours_chg_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_vesc_status_2_amp_hours_chg_decode(int32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_vesc_status_2_amp_hours_chg_is_in_range(int32_t value);

/**
 * Pack message vesc_status_4.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can1_vesc_status_4_pack(
    uint8_t *dst_p,
    const struct can1_vesc_status_4_t *src_p,
    size_t size);

/**
 * Unpack message vesc_status_4.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can1_vesc_status_4_unpack(
    struct can1_vesc_status_4_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_vesc_status_4_temp_fet_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_vesc_status_4_temp_fet_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_vesc_status_4_temp_fet_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_vesc_status_4_temp_motor_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_vesc_status_4_temp_motor_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_vesc_status_4_temp_motor_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_vesc_status_4_current_in_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_vesc_status_4_current_in_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_vesc_status_4_current_in_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_vesc_status_4_pid_pos_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_vesc_status_4_pid_pos_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_vesc_status_4_pid_pos_is_in_range(int16_t value);

/**
 * Pack message vesc_status_5.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can1_vesc_status_5_pack(
    uint8_t *dst_p,
    const struct can1_vesc_status_5_t *src_p,
    size_t size);

/**
 * Unpack message vesc_status_5.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can1_vesc_status_5_unpack(
    struct can1_vesc_status_5_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int32_t can1_vesc_status_5_tachometer_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_vesc_status_5_tachometer_decode(int32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_vesc_status_5_tachometer_is_in_range(int32_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_vesc_status_5_volts_in_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_vesc_status_5_volts_in_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_vesc_status_5_volts_in_is_in_range(int16_t value);

/**
 * Pack message vesc_status_6.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can1_vesc_status_6_pack(
    uint8_t *dst_p,
    const struct can1_vesc_status_6_t *src_p,
    size_t size);

/**
 * Unpack message vesc_status_6.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can1_vesc_status_6_unpack(
    struct can1_vesc_status_6_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_vesc_status_6_adc1_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_vesc_status_6_adc1_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_vesc_status_6_adc1_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_vesc_status_6_adc2_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_vesc_status_6_adc2_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_vesc_status_6_adc2_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_vesc_status_6_adc3_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_vesc_status_6_adc3_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_vesc_status_6_adc3_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_vesc_status_6_ppm_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_vesc_status_6_ppm_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_vesc_status_6_ppm_is_in_range(int16_t value);

/**
 * Pack message vesc_set_duty.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can1_vesc_set_duty_pack(
    uint8_t *dst_p,
    const struct can1_vesc_set_duty_t *src_p,
    size_t size);

/**
 * Unpack message vesc_set_duty.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can1_vesc_set_duty_unpack(
    struct can1_vesc_set_duty_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int32_t can1_vesc_set_duty_set_duty_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_vesc_set_duty_set_duty_decode(int32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_vesc_set_duty_set_duty_is_in_range(int32_t value);

/**
 * Pack message vesc_status.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can1_vesc_status_pack(
    uint8_t *dst_p,
    const struct can1_vesc_status_t *src_p,
    size_t size);

/**
 * Unpack message vesc_status.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can1_vesc_status_unpack(
    struct can1_vesc_status_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int32_t can1_vesc_status_erpm_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_vesc_status_erpm_decode(int32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_vesc_status_erpm_is_in_range(int32_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_vesc_status_current_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_vesc_status_current_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_vesc_status_current_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_vesc_status_duty_cycle_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_vesc_status_duty_cycle_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_vesc_status_duty_cycle_is_in_range(int16_t value);

/**
 * Pack message ams_s1_voltages_1.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can1_ams_s1_voltages_1_pack(
    uint8_t *dst_p,
    const struct can1_ams_s1_voltages_1_t *src_p,
    size_t size);

/**
 * Unpack message ams_s1_voltages_1.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can1_ams_s1_voltages_1_unpack(
    struct can1_ams_s1_voltages_1_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_s1_voltages_1_s1v1_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_s1_voltages_1_s1v1_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_s1_voltages_1_s1v1_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_s1_voltages_1_s1v2_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_s1_voltages_1_s1v2_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_s1_voltages_1_s1v2_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_s1_voltages_1_s1v3_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_s1_voltages_1_s1v3_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_s1_voltages_1_s1v3_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_s1_voltages_1_s1v4_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_s1_voltages_1_s1v4_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_s1_voltages_1_s1v4_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_s1_voltages_1_s1v5_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_s1_voltages_1_s1v5_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_s1_voltages_1_s1v5_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_s1_voltages_1_s1v6_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_s1_voltages_1_s1v6_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_s1_voltages_1_s1v6_is_in_range(uint8_t value);

/**
 * Pack message ams_s1_voltages_2.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can1_ams_s1_voltages_2_pack(
    uint8_t *dst_p,
    const struct can1_ams_s1_voltages_2_t *src_p,
    size_t size);

/**
 * Unpack message ams_s1_voltages_2.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can1_ams_s1_voltages_2_unpack(
    struct can1_ams_s1_voltages_2_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_s1_voltages_2_s1v7_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_s1_voltages_2_s1v7_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_s1_voltages_2_s1v7_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_s1_voltages_2_s1v8_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_s1_voltages_2_s1v8_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_s1_voltages_2_s1v8_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_s1_voltages_2_s1v9_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_s1_voltages_2_s1v9_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_s1_voltages_2_s1v9_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_s1_voltages_2_s1v10_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_s1_voltages_2_s1v10_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_s1_voltages_2_s1v10_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_s1_voltages_2_s1v11_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_s1_voltages_2_s1v11_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_s1_voltages_2_s1v11_is_in_range(uint8_t value);

/**
 * Pack message ams_s2_voltages_1.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can1_ams_s2_voltages_1_pack(
    uint8_t *dst_p,
    const struct can1_ams_s2_voltages_1_t *src_p,
    size_t size);

/**
 * Unpack message ams_s2_voltages_1.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can1_ams_s2_voltages_1_unpack(
    struct can1_ams_s2_voltages_1_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_s2_voltages_1_s2v1_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_s2_voltages_1_s2v1_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_s2_voltages_1_s2v1_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_s2_voltages_1_s2v2_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_s2_voltages_1_s2v2_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_s2_voltages_1_s2v2_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_s2_voltages_1_s2v3_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_s2_voltages_1_s2v3_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_s2_voltages_1_s2v3_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_s2_voltages_1_s2v4_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_s2_voltages_1_s2v4_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_s2_voltages_1_s2v4_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_s2_voltages_1_s2v5_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_s2_voltages_1_s2v5_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_s2_voltages_1_s2v5_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_s2_voltages_1_s2v6_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_s2_voltages_1_s2v6_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_s2_voltages_1_s2v6_is_in_range(uint8_t value);

/**
 * Pack message ams_s2_voltages_2.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can1_ams_s2_voltages_2_pack(
    uint8_t *dst_p,
    const struct can1_ams_s2_voltages_2_t *src_p,
    size_t size);

/**
 * Unpack message ams_s2_voltages_2.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can1_ams_s2_voltages_2_unpack(
    struct can1_ams_s2_voltages_2_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_s2_voltages_2_s2v7_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_s2_voltages_2_s2v7_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_s2_voltages_2_s2v7_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_s2_voltages_2_s2v8_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_s2_voltages_2_s2v8_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_s2_voltages_2_s2v8_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_s2_voltages_2_s2v9_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_s2_voltages_2_s2v9_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_s2_voltages_2_s2v9_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_s2_voltages_2_s2v10_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_s2_voltages_2_s2v10_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_s2_voltages_2_s2v10_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_s2_voltages_2_s2v11_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_s2_voltages_2_s2v11_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_s2_voltages_2_s2v11_is_in_range(uint8_t value);

/**
 * Pack message ams_s3_voltages_1.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can1_ams_s3_voltages_1_pack(
    uint8_t *dst_p,
    const struct can1_ams_s3_voltages_1_t *src_p,
    size_t size);

/**
 * Unpack message ams_s3_voltages_1.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can1_ams_s3_voltages_1_unpack(
    struct can1_ams_s3_voltages_1_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_s3_voltages_1_s3v1_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_s3_voltages_1_s3v1_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_s3_voltages_1_s3v1_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_s3_voltages_1_s3v2_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_s3_voltages_1_s3v2_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_s3_voltages_1_s3v2_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_s3_voltages_1_s3v3_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_s3_voltages_1_s3v3_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_s3_voltages_1_s3v3_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_s3_voltages_1_s3v4_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_s3_voltages_1_s3v4_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_s3_voltages_1_s3v4_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_s3_voltages_1_s3v5_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_s3_voltages_1_s3v5_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_s3_voltages_1_s3v5_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_s3_voltages_1_s3v6_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_s3_voltages_1_s3v6_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_s3_voltages_1_s3v6_is_in_range(uint8_t value);

/**
 * Pack message ams_s3_voltages_2.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can1_ams_s3_voltages_2_pack(
    uint8_t *dst_p,
    const struct can1_ams_s3_voltages_2_t *src_p,
    size_t size);

/**
 * Unpack message ams_s3_voltages_2.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can1_ams_s3_voltages_2_unpack(
    struct can1_ams_s3_voltages_2_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_s3_voltages_2_s3v7_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_s3_voltages_2_s3v7_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_s3_voltages_2_s3v7_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_s3_voltages_2_s3v8_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_s3_voltages_2_s3v8_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_s3_voltages_2_s3v8_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_s3_voltages_2_s3v9_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_s3_voltages_2_s3v9_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_s3_voltages_2_s3v9_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_s3_voltages_2_s3v10_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_s3_voltages_2_s3v10_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_s3_voltages_2_s3v10_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_s3_voltages_2_s3v11_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_s3_voltages_2_s3v11_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_s3_voltages_2_s3v11_is_in_range(uint8_t value);

/**
 * Pack message ams_s4_voltages_1.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can1_ams_s4_voltages_1_pack(
    uint8_t *dst_p,
    const struct can1_ams_s4_voltages_1_t *src_p,
    size_t size);

/**
 * Unpack message ams_s4_voltages_1.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can1_ams_s4_voltages_1_unpack(
    struct can1_ams_s4_voltages_1_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_s4_voltages_1_s4v1_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_s4_voltages_1_s4v1_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_s4_voltages_1_s4v1_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_s4_voltages_1_s4v2_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_s4_voltages_1_s4v2_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_s4_voltages_1_s4v2_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_s4_voltages_1_s4v3_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_s4_voltages_1_s4v3_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_s4_voltages_1_s4v3_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_s4_voltages_1_s4v4_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_s4_voltages_1_s4v4_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_s4_voltages_1_s4v4_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_s4_voltages_1_s4v5_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_s4_voltages_1_s4v5_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_s4_voltages_1_s4v5_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_s4_voltages_1_s4v6_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_s4_voltages_1_s4v6_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_s4_voltages_1_s4v6_is_in_range(uint8_t value);

/**
 * Pack message ams_s4_voltages_2.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can1_ams_s4_voltages_2_pack(
    uint8_t *dst_p,
    const struct can1_ams_s4_voltages_2_t *src_p,
    size_t size);

/**
 * Unpack message ams_s4_voltages_2.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can1_ams_s4_voltages_2_unpack(
    struct can1_ams_s4_voltages_2_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_s4_voltages_2_s4v7_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_s4_voltages_2_s4v7_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_s4_voltages_2_s4v7_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_s4_voltages_2_s4v8_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_s4_voltages_2_s4v8_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_s4_voltages_2_s4v8_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_s4_voltages_2_s4v9_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_s4_voltages_2_s4v9_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_s4_voltages_2_s4v9_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_s4_voltages_2_s4v10_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_s4_voltages_2_s4v10_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_s4_voltages_2_s4v10_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_s4_voltages_2_s4v11_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_s4_voltages_2_s4v11_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_s4_voltages_2_s4v11_is_in_range(uint8_t value);

/**
 * Pack message ams_s5_voltages_1.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can1_ams_s5_voltages_1_pack(
    uint8_t *dst_p,
    const struct can1_ams_s5_voltages_1_t *src_p,
    size_t size);

/**
 * Unpack message ams_s5_voltages_1.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can1_ams_s5_voltages_1_unpack(
    struct can1_ams_s5_voltages_1_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_s5_voltages_1_s5v1_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_s5_voltages_1_s5v1_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_s5_voltages_1_s5v1_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_s5_voltages_1_s5v2_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_s5_voltages_1_s5v2_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_s5_voltages_1_s5v2_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_s5_voltages_1_s5v3_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_s5_voltages_1_s5v3_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_s5_voltages_1_s5v3_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_s5_voltages_1_s5v4_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_s5_voltages_1_s5v4_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_s5_voltages_1_s5v4_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_s5_voltages_1_s5v5_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_s5_voltages_1_s5v5_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_s5_voltages_1_s5v5_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_s5_voltages_1_s5v6_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_s5_voltages_1_s5v6_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_s5_voltages_1_s5v6_is_in_range(uint8_t value);

/**
 * Pack message ams_s5_voltages_2.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can1_ams_s5_voltages_2_pack(
    uint8_t *dst_p,
    const struct can1_ams_s5_voltages_2_t *src_p,
    size_t size);

/**
 * Unpack message ams_s5_voltages_2.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can1_ams_s5_voltages_2_unpack(
    struct can1_ams_s5_voltages_2_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_s5_voltages_2_s5v7_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_s5_voltages_2_s5v7_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_s5_voltages_2_s5v7_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_s5_voltages_2_s5v8_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_s5_voltages_2_s5v8_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_s5_voltages_2_s5v8_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_s5_voltages_2_s5v9_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_s5_voltages_2_s5v9_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_s5_voltages_2_s5v9_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_s5_voltages_2_s5v10_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_s5_voltages_2_s5v10_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_s5_voltages_2_s5v10_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_s5_voltages_2_s5v11_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_s5_voltages_2_s5v11_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_s5_voltages_2_s5v11_is_in_range(uint8_t value);

/**
 * Pack message ams_s6_voltages_1.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can1_ams_s6_voltages_1_pack(
    uint8_t *dst_p,
    const struct can1_ams_s6_voltages_1_t *src_p,
    size_t size);

/**
 * Unpack message ams_s6_voltages_1.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can1_ams_s6_voltages_1_unpack(
    struct can1_ams_s6_voltages_1_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_s6_voltages_1_s6v1_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_s6_voltages_1_s6v1_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_s6_voltages_1_s6v1_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_s6_voltages_1_s6v2_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_s6_voltages_1_s6v2_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_s6_voltages_1_s6v2_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_s6_voltages_1_s6v3_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_s6_voltages_1_s6v3_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_s6_voltages_1_s6v3_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_s6_voltages_1_s6v4_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_s6_voltages_1_s6v4_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_s6_voltages_1_s6v4_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_s6_voltages_1_s6v5_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_s6_voltages_1_s6v5_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_s6_voltages_1_s6v5_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_s6_voltages_1_s6v6_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_s6_voltages_1_s6v6_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_s6_voltages_1_s6v6_is_in_range(uint8_t value);

/**
 * Pack message ams_s6_voltages_2.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can1_ams_s6_voltages_2_pack(
    uint8_t *dst_p,
    const struct can1_ams_s6_voltages_2_t *src_p,
    size_t size);

/**
 * Unpack message ams_s6_voltages_2.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can1_ams_s6_voltages_2_unpack(
    struct can1_ams_s6_voltages_2_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_s6_voltages_2_s6v7_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_s6_voltages_2_s6v7_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_s6_voltages_2_s6v7_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_s6_voltages_2_s6v8_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_s6_voltages_2_s6v8_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_s6_voltages_2_s6v8_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_s6_voltages_2_s6v9_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_s6_voltages_2_s6v9_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_s6_voltages_2_s6v9_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_s6_voltages_2_s6v10_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_s6_voltages_2_s6v10_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_s6_voltages_2_s6v10_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_s6_voltages_2_s6v11_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_s6_voltages_2_s6v11_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_s6_voltages_2_s6v11_is_in_range(uint8_t value);

/**
 * Pack message ams_s7_voltages_1.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can1_ams_s7_voltages_1_pack(
    uint8_t *dst_p,
    const struct can1_ams_s7_voltages_1_t *src_p,
    size_t size);

/**
 * Unpack message ams_s7_voltages_1.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can1_ams_s7_voltages_1_unpack(
    struct can1_ams_s7_voltages_1_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_s7_voltages_1_s7v1_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_s7_voltages_1_s7v1_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_s7_voltages_1_s7v1_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_s7_voltages_1_s7v2_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_s7_voltages_1_s7v2_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_s7_voltages_1_s7v2_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_s7_voltages_1_s7v3_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_s7_voltages_1_s7v3_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_s7_voltages_1_s7v3_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_s7_voltages_1_s7v4_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_s7_voltages_1_s7v4_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_s7_voltages_1_s7v4_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_s7_voltages_1_s7v5_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_s7_voltages_1_s7v5_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_s7_voltages_1_s7v5_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_s7_voltages_1_s7v6_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_s7_voltages_1_s7v6_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_s7_voltages_1_s7v6_is_in_range(uint8_t value);

/**
 * Pack message ams_s7_voltages_2.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can1_ams_s7_voltages_2_pack(
    uint8_t *dst_p,
    const struct can1_ams_s7_voltages_2_t *src_p,
    size_t size);

/**
 * Unpack message ams_s7_voltages_2.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can1_ams_s7_voltages_2_unpack(
    struct can1_ams_s7_voltages_2_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_s7_voltages_2_s7v7_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_s7_voltages_2_s7v7_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_s7_voltages_2_s7v7_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_s7_voltages_2_s7v8_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_s7_voltages_2_s7v8_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_s7_voltages_2_s7v8_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_s7_voltages_2_s7v9_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_s7_voltages_2_s7v9_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_s7_voltages_2_s7v9_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_s7_voltages_2_s7v10_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_s7_voltages_2_s7v10_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_s7_voltages_2_s7v10_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_s7_voltages_2_s7v11_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_s7_voltages_2_s7v11_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_s7_voltages_2_s7v11_is_in_range(uint8_t value);

/**
 * Pack message ams_s8_voltages_1.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can1_ams_s8_voltages_1_pack(
    uint8_t *dst_p,
    const struct can1_ams_s8_voltages_1_t *src_p,
    size_t size);

/**
 * Unpack message ams_s8_voltages_1.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can1_ams_s8_voltages_1_unpack(
    struct can1_ams_s8_voltages_1_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_s8_voltages_1_s8v1_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_s8_voltages_1_s8v1_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_s8_voltages_1_s8v1_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_s8_voltages_1_s8v2_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_s8_voltages_1_s8v2_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_s8_voltages_1_s8v2_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_s8_voltages_1_s8v3_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_s8_voltages_1_s8v3_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_s8_voltages_1_s8v3_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_s8_voltages_1_s8v4_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_s8_voltages_1_s8v4_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_s8_voltages_1_s8v4_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_s8_voltages_1_s8v5_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_s8_voltages_1_s8v5_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_s8_voltages_1_s8v5_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_s8_voltages_1_s8v6_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_s8_voltages_1_s8v6_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_s8_voltages_1_s8v6_is_in_range(uint8_t value);

/**
 * Pack message ams_s8_voltages_2.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can1_ams_s8_voltages_2_pack(
    uint8_t *dst_p,
    const struct can1_ams_s8_voltages_2_t *src_p,
    size_t size);

/**
 * Unpack message ams_s8_voltages_2.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can1_ams_s8_voltages_2_unpack(
    struct can1_ams_s8_voltages_2_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_s8_voltages_2_s8v7_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_s8_voltages_2_s8v7_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_s8_voltages_2_s8v7_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_s8_voltages_2_s8v8_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_s8_voltages_2_s8v8_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_s8_voltages_2_s8v8_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_s8_voltages_2_s8v9_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_s8_voltages_2_s8v9_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_s8_voltages_2_s8v9_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_s8_voltages_2_s8v10_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_s8_voltages_2_s8v10_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_s8_voltages_2_s8v10_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_s8_voltages_2_s8v11_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_s8_voltages_2_s8v11_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_s8_voltages_2_s8v11_is_in_range(uint8_t value);

/**
 * Pack message ams_s9_voltages_1.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can1_ams_s9_voltages_1_pack(
    uint8_t *dst_p,
    const struct can1_ams_s9_voltages_1_t *src_p,
    size_t size);

/**
 * Unpack message ams_s9_voltages_1.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can1_ams_s9_voltages_1_unpack(
    struct can1_ams_s9_voltages_1_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_s9_voltages_1_s9v1_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_s9_voltages_1_s9v1_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_s9_voltages_1_s9v1_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_s9_voltages_1_s9v2_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_s9_voltages_1_s9v2_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_s9_voltages_1_s9v2_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_s9_voltages_1_s9v3_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_s9_voltages_1_s9v3_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_s9_voltages_1_s9v3_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_s9_voltages_1_s9v4_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_s9_voltages_1_s9v4_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_s9_voltages_1_s9v4_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_s9_voltages_1_s9v5_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_s9_voltages_1_s9v5_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_s9_voltages_1_s9v5_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_s9_voltages_1_s9v6_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_s9_voltages_1_s9v6_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_s9_voltages_1_s9v6_is_in_range(uint8_t value);

/**
 * Pack message ams_s9_voltages_2.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can1_ams_s9_voltages_2_pack(
    uint8_t *dst_p,
    const struct can1_ams_s9_voltages_2_t *src_p,
    size_t size);

/**
 * Unpack message ams_s9_voltages_2.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can1_ams_s9_voltages_2_unpack(
    struct can1_ams_s9_voltages_2_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_s9_voltages_2_s9v7_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_s9_voltages_2_s9v7_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_s9_voltages_2_s9v7_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_s9_voltages_2_s9v8_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_s9_voltages_2_s9v8_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_s9_voltages_2_s9v8_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_s9_voltages_2_s9v9_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_s9_voltages_2_s9v9_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_s9_voltages_2_s9v9_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_s9_voltages_2_s9v10_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_s9_voltages_2_s9v10_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_s9_voltages_2_s9v10_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_s9_voltages_2_s9v11_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_s9_voltages_2_s9v11_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_s9_voltages_2_s9v11_is_in_range(uint8_t value);

/**
 * Pack message ams_s10_voltages_1.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can1_ams_s10_voltages_1_pack(
    uint8_t *dst_p,
    const struct can1_ams_s10_voltages_1_t *src_p,
    size_t size);

/**
 * Unpack message ams_s10_voltages_1.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can1_ams_s10_voltages_1_unpack(
    struct can1_ams_s10_voltages_1_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_s10_voltages_1_s10v1_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_s10_voltages_1_s10v1_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_s10_voltages_1_s10v1_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_s10_voltages_1_s10v2_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_s10_voltages_1_s10v2_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_s10_voltages_1_s10v2_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_s10_voltages_1_s10v3_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_s10_voltages_1_s10v3_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_s10_voltages_1_s10v3_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_s10_voltages_1_s10v4_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_s10_voltages_1_s10v4_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_s10_voltages_1_s10v4_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_s10_voltages_1_s10v5_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_s10_voltages_1_s10v5_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_s10_voltages_1_s10v5_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_s10_voltages_1_s10v6_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_s10_voltages_1_s10v6_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_s10_voltages_1_s10v6_is_in_range(uint8_t value);

/**
 * Pack message ams_s10_voltages_2.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can1_ams_s10_voltages_2_pack(
    uint8_t *dst_p,
    const struct can1_ams_s10_voltages_2_t *src_p,
    size_t size);

/**
 * Unpack message ams_s10_voltages_2.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can1_ams_s10_voltages_2_unpack(
    struct can1_ams_s10_voltages_2_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_s10_voltages_2_s10v7_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_s10_voltages_2_s10v7_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_s10_voltages_2_s10v7_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_s10_voltages_2_s10v8_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_s10_voltages_2_s10v8_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_s10_voltages_2_s10v8_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_s10_voltages_2_s10v9_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_s10_voltages_2_s10v9_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_s10_voltages_2_s10v9_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_s10_voltages_2_s10v10_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_s10_voltages_2_s10v10_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_s10_voltages_2_s10v10_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_s10_voltages_2_s10v11_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_s10_voltages_2_s10v11_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_s10_voltages_2_s10v11_is_in_range(uint8_t value);

/**
 * Pack message ams_s11_voltages_1.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can1_ams_s11_voltages_1_pack(
    uint8_t *dst_p,
    const struct can1_ams_s11_voltages_1_t *src_p,
    size_t size);

/**
 * Unpack message ams_s11_voltages_1.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can1_ams_s11_voltages_1_unpack(
    struct can1_ams_s11_voltages_1_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_s11_voltages_1_s11v1_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_s11_voltages_1_s11v1_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_s11_voltages_1_s11v1_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_s11_voltages_1_s11v2_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_s11_voltages_1_s11v2_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_s11_voltages_1_s11v2_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_s11_voltages_1_s11v3_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_s11_voltages_1_s11v3_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_s11_voltages_1_s11v3_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_s11_voltages_1_s11v4_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_s11_voltages_1_s11v4_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_s11_voltages_1_s11v4_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_s11_voltages_1_s11v5_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_s11_voltages_1_s11v5_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_s11_voltages_1_s11v5_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_s11_voltages_1_s11v6_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_s11_voltages_1_s11v6_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_s11_voltages_1_s11v6_is_in_range(uint8_t value);

/**
 * Pack message ams_s11_voltages_2.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can1_ams_s11_voltages_2_pack(
    uint8_t *dst_p,
    const struct can1_ams_s11_voltages_2_t *src_p,
    size_t size);

/**
 * Unpack message ams_s11_voltages_2.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can1_ams_s11_voltages_2_unpack(
    struct can1_ams_s11_voltages_2_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_s11_voltages_2_s11v7_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_s11_voltages_2_s11v7_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_s11_voltages_2_s11v7_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_s11_voltages_2_s11v8_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_s11_voltages_2_s11v8_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_s11_voltages_2_s11v8_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_s11_voltages_2_s11v9_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_s11_voltages_2_s11v9_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_s11_voltages_2_s11v9_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_s11_voltages_2_s11v10_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_s11_voltages_2_s11v10_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_s11_voltages_2_s11v10_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_s11_voltages_2_s11v11_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_s11_voltages_2_s11v11_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_s11_voltages_2_s11v11_is_in_range(uint8_t value);

/**
 * Pack message ams_s12_voltages_1.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can1_ams_s12_voltages_1_pack(
    uint8_t *dst_p,
    const struct can1_ams_s12_voltages_1_t *src_p,
    size_t size);

/**
 * Unpack message ams_s12_voltages_1.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can1_ams_s12_voltages_1_unpack(
    struct can1_ams_s12_voltages_1_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_s12_voltages_1_s12v1_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_s12_voltages_1_s12v1_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_s12_voltages_1_s12v1_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_s12_voltages_1_s12v2_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_s12_voltages_1_s12v2_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_s12_voltages_1_s12v2_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_s12_voltages_1_s12v3_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_s12_voltages_1_s12v3_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_s12_voltages_1_s12v3_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_s12_voltages_1_s12v4_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_s12_voltages_1_s12v4_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_s12_voltages_1_s12v4_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_s12_voltages_1_s12v5_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_s12_voltages_1_s12v5_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_s12_voltages_1_s12v5_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_s12_voltages_1_s12v6_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_s12_voltages_1_s12v6_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_s12_voltages_1_s12v6_is_in_range(uint8_t value);

/**
 * Pack message ams_s12_voltages_2.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can1_ams_s12_voltages_2_pack(
    uint8_t *dst_p,
    const struct can1_ams_s12_voltages_2_t *src_p,
    size_t size);

/**
 * Unpack message ams_s12_voltages_2.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can1_ams_s12_voltages_2_unpack(
    struct can1_ams_s12_voltages_2_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_s12_voltages_2_s12v7_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_s12_voltages_2_s12v7_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_s12_voltages_2_s12v7_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_s12_voltages_2_s12v8_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_s12_voltages_2_s12v8_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_s12_voltages_2_s12v8_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_s12_voltages_2_s12v9_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_s12_voltages_2_s12v9_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_s12_voltages_2_s12v9_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_s12_voltages_2_s12v10_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_s12_voltages_2_s12v10_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_s12_voltages_2_s12v10_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_s12_voltages_2_s12v11_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_s12_voltages_2_s12v11_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_s12_voltages_2_s12v11_is_in_range(uint8_t value);

/**
 * Pack message ivt_improved_status.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can1_ivt_improved_status_pack(
    uint8_t *dst_p,
    const struct can1_ivt_improved_status_t *src_p,
    size_t size);

/**
 * Unpack message ivt_improved_status.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can1_ivt_improved_status_unpack(
    struct can1_ivt_improved_status_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can1_ivt_improved_status_ivt_voltage_battery_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ivt_improved_status_ivt_voltage_battery_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ivt_improved_status_ivt_voltage_battery_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can1_ivt_improved_status_ivt_voltage_vehicle_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ivt_improved_status_ivt_voltage_vehicle_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ivt_improved_status_ivt_voltage_vehicle_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_ivt_improved_status_ivt_current_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ivt_improved_status_ivt_current_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ivt_improved_status_ivt_current_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ivt_improved_status_temp_h_vplus_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ivt_improved_status_temp_h_vplus_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ivt_improved_status_temp_h_vplus_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ivt_improved_status_temp_h_vminus_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ivt_improved_status_temp_h_vminus_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ivt_improved_status_temp_h_vminus_is_in_range(uint8_t value);

/**
 * Pack message res_recieve_PDO.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can1_res_recieve_pdo_pack(
    uint8_t *dst_p,
    const struct can1_res_recieve_pdo_t *src_p,
    size_t size);

/**
 * Unpack message res_recieve_PDO.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can1_res_recieve_pdo_unpack(
    struct can1_res_recieve_pdo_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Pack message res_transmit_SDO.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can1_res_transmit_sdo_pack(
    uint8_t *dst_p,
    const struct can1_res_transmit_sdo_t *src_p,
    size_t size);

/**
 * Unpack message res_transmit_SDO.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can1_res_transmit_sdo_unpack(
    struct can1_res_transmit_sdo_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Pack message res_recieve_SDO.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can1_res_recieve_sdo_pack(
    uint8_t *dst_p,
    const struct can1_res_recieve_sdo_t *src_p,
    size_t size);

/**
 * Unpack message res_recieve_SDO.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can1_res_recieve_sdo_unpack(
    struct can1_res_recieve_sdo_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Pack message res_transmit_LSS.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can1_res_transmit_lss_pack(
    uint8_t *dst_p,
    const struct can1_res_transmit_lss_t *src_p,
    size_t size);

/**
 * Unpack message res_transmit_LSS.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can1_res_transmit_lss_unpack(
    struct can1_res_transmit_lss_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Pack message res_recieve_LSS.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can1_res_recieve_lss_pack(
    uint8_t *dst_p,
    const struct can1_res_recieve_lss_t *src_p,
    size_t size);

/**
 * Unpack message res_recieve_LSS.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can1_res_recieve_lss_unpack(
    struct can1_res_recieve_lss_t *dst_p,
    const uint8_t *src_p,
    size_t size);


#ifdef __cplusplus
}
#endif

#endif
